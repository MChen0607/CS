# JVM（Java虚拟机）知识

# 概述

Java技术体系：

JCP官方定义的Java技术体系包括：（Java社区，社区组织，用来定义和发展Java的技术规范）

- Java程序设计语言（Java语言本身）
- 各种硬件平台上的Java虚拟机（JVM，不同的硬件平台jvm不同）
- class文件格式
- Java API类库（系统自带的，eg：包装类、容器等）
- 来自第三方的Java类库

JDK（Java development kit）：Java语言 + JVM + Java API类库——是支持Java开发的最小环境

JRE（Java runtime environment）：Java API类库中的Java SE API子集 + JVM——是支持Java运行的标准环境

（Java SE：Java standard edition）

（从广义上讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员）

<img src="pic\image-20201221091059509.png" alt="image-20201221091059509"  />

Java可以分为4个技术平台：Java Card（小内存设备上）、Java ME（移动终端，但是Android并不属于Java ME）、Java SE（standard edition，支持面向桌面级应用，提供完整的Java核心API）、Java EE（支持企业应用，提供SE API+大量扩充）

Hot-Spot虚拟机成为JDK 1.3及之后所有JDK版本的默认Java虚拟机，目前仍是最主流的JVM版本。

Hot-Spot虚拟机有热点代码探测能力：可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-StackReplacement，OSR）行为——将会被替换为物理硬件可以直接执行的机器码。

# 一、自动内存管理机制

Java内存区域和内存溢出异常；垃圾收集器和内存分配策略；虚拟机性能监控和故障处理工具；调优案例分析与实战

## chap1 Java内存区域和内存溢出异常

c、c++，需要自行管理内存领域，程序具有有最高统治权：负责分配、维护、销毁每一个内存对象

Java，**虚拟机会进行内存管理**，只需要new对象，而不需要去释放（free）对象。那么不容易出现内存泄漏和内存溢出的问题（内存泄漏是失去的对该内存的管理权，不断泄漏最终导致了内存溢出现象，具体见[计算机常见概念1](http://note.youdao.com/noteshare?id=eb547cdfc6c85c3c30ca9d0698c920d2&sub=3651306AE01B41B89750DF274F97A550)）

=>但是存在的问题是：

一旦内存管理出现了问题，将很难排查出问题

=> 了解虚拟机的目的之一：了解其如何进行内存管理的

### 1. JVM运行时数据区域

 JVM会将其管理的内存区域分为多个不同的数据区域，每个区域功能不同，创建和销毁时间不同

下图就是JVM所分割的数据区域：

<img src="pic\image-20201217120034612.png" alt="image-20201217120034612" style="zoom:67%;" />

#### （1）程序计数器（PC）<私有>

生命周期和线程一样

实际上就是一个字长的单位（未确定？？？）

当前线程所在执行的字节码的行号指示器，即：当前运行到的位置（类似于CPU的pc指针）

**字节码解释器**就是通过改变该pc值来获取下一条字节码指令。分支、跳转、循环、异常处理、线程恢复都是通过该pc完成的。

pc存在的原因：JVM是多线程切换执行的，所以要能够切换到一个线程再切换回来，需要能够回到上次的执行位置，所以需要**独立存储一个pc值**——每个线程的pc值独立存储，互不影响

- 如果线程正在执行的是Java方法，那么pc指向的是JVM的字节码指令地址；——所以pc就只是指示Java程序的执行位置

- 如果正在执行native方法，那么pc为空（undefined）

  （native方法：原生函数，就是用c/c++实现，并被编译成DLL，然后Java能够进行调用）

程序计数器区域：是唯一一个在JVM中没有规定任何`OutOfMemoryError`（内存溢出错误）的区域——因为有且只有一个字段且只改变里面的值，不存在溢出

#### （2）虚拟机栈（VM Stack）<私有>

生命周期和线程一样。

虚拟机栈描述的是，Java方法执行的内存模型：每个方法在执行时会创建一个**栈帧**用来存储：局部变量表、操作数栈、动态链接、方法出口等。一个方法从调用到执行完成会对应一个栈帧在虚拟机中入栈到出栈的过程

（栈帧是方法运行时的基础数据结构，chap8会讲）

局部变量表：（用局部变量槽来表示，long和double类型的变量会占据2个槽，其余占用1个槽）

- 存放的是编译期可知的基本数据类型（值本身）——**8种基本数据类型的值都是直接存放在虚拟机栈中的**

  其中double、long类型是64位的，占据2个局部变量空间（占据2个slot），其余数据类型只占用1个

- 对象引用（不是对象本身（存放在堆中），而是对象起始地址的引用指针，或者是对象的句柄或者与此对象相关的位置）

  占用一个空间

- returnAddress类型（指向字节码指令的地址，就是指向程序的指针）

  占用一个空间

**局部变量表的空间在编译期间确定并完成分配**，当进入一个方法时，**该空间确定且不会变化**

（这里的分配是按照变量槽为单位的，不变是指变量槽数量不变）

对虚拟机栈规定了两种异常：

1. 如果线程请求的栈深度大于虚拟机允许的深度，那么抛出**`StackOverflowError`异常**（堆栈溢出异常）

2. 如果虚拟机栈大小可以动态扩展（大部分允许扩展，也可以要求固定），如果扩展时申请不到足够内存，那么抛出**`OutOfMemoryError`异常**（内存溢出异常，即常见的OOM异常）

   （ps：HotSpot不允许栈容量的扩大，所以是不会因为动态扩展而抛出OOM——只要线程在初始申请栈空间就行，但是存在线程在初始申请栈空间时就失败了，那么仍然会抛出OOM，只不过此时触发OOM的场景不同）

#### （3）本地方法栈<私有>

与虚拟机栈类似，但是本地方法栈是为Native方法服务的；而虚拟机栈是为Java方法服务的

虚拟机规范没有规定本地方法栈的使用方式等；具体虚拟机可以自由实现。

**同样规定两个异常：`StackOverflowError`和`OutOfMemoryError`**

（ps：HotSpot将本地方法栈合并到虚拟机栈中了）

#### （4）Java堆<共享>

大部分应用来说，**Java heap是虚拟机管理的内存中最大的一块**。

所有线程共享，生命周期和虚拟机一样

该内存区的唯一目的：**存放对象实例。Java虚拟机规范要求：所有的对象实例和数组都要在堆上分配**（随着技术发展，不是很绝对了，eg：逃逸分析技术、栈上分配、标量替换导致对象不一定要在栈上分配）

Java堆的细分（只是设计风格，JVM规范并没有规定）：

- 从回收内存的方式来看，**Java堆是垃圾收集器管理的主要区域，所常被称为GC堆（垃圾收集堆）**。**现代垃圾收集器大部分都是基于分代收集理论设计的**，所以会出现“新生代”、“老生代”、“永久代”等名词，但这只是设计风格，并不是JVM具体实现的固有内存布局（即分代只是概念上的，而具体不会去这么构建内存布局），JVM规范并没有将堆继续细分
- 从分配内存的角度，在Java堆中可以划分出多个TLAB，用来提升对象分配时的效率。但是无论如何划分，Java堆的唯一目的就是存储对象实例，而Java堆的细分指示为了更好的分配和回收内存

**Java堆在物理上可以是不连续的空间**，只需要在逻辑空间连续即可（类比于操作系统的虚拟内存映射）。

但是**对于大对象（eg：数组对象等），为实现简单、存储高效（直接索引）的考虑要求是分配连续的物理内存空间**

Java堆实现时：可以是固定大小的，也可以是可扩展的（主流是，通过-Xmx和-Xms控制）。

规定的异常：如果堆中没有多余的内存完成实例分配，堆也无法再扩展，那么会抛出**`OutOfMemoryError`异常**

（ps：HotSpot内部的垃圾收集器是按照“经典分代”来设计的，但是也出现了不按照分代设计的新垃圾收集器）

#### （5）方法区<共享>

生命周期和虚拟机一样

存储：**被加载的类信息、常量、静态变量、即时编译器编译后的代码等**

Java虚拟机规范**将方法区描述为堆的一个逻辑部分**，但又被称为“非堆”（Non-Heap），为了将其和Java堆区分。

Java虚拟机规范对方法区的实现要求很宽松：物理地址不需要连续，只需要逻辑上连续即可；可选择不实现垃圾收集。

——但是还是可以存在垃圾收集行为的：主要是针对**常量池的回收和对类型的卸载**

尤其是类型卸载，条件苛刻，但是还是存在必要的

规范规定的异常：当方法区无法满足内存分配需要时，抛出**`OutOfMemoryError`异常**。

#### （6）运行时常量池<共享>——方法区的一部分

Class文件会有：类的版本、字段、方法、接口等，还有**常量池表**，存放**编译期生成的各种字面量和符号引用**——这部分在类加载之后进入方法区的运行时常量池

规范对运行时常量池无任何细节要求，可以自行实现。一般运行时常量池中也会存储翻译出来的直接引用（所以总结：运行时常量池会存放字面量、符号引用、直接引用）

运行时常量池：相对于Class文件常量池的一个重要特征是：**具备动态性**，常量不一定只能在编译期产生，在运行期间还能将新的常量放入池中，eg：String类的intern()方法

规范规定的异常：当方法区无法满足内存分配需要时，抛出**`OutOfMemoryError`异常**。

#### （7）直接内存

不是JVM数据区的一部分，也不是规范中定义的内存区域，但是使用频繁——在本机上单独申请的一块内存

JDK1.4中加入NIO（新IO）类，引入了基于通道和缓冲区的IO方式，使用了Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的对象`DirectByteBuffer`来引用该块内存，然后进行操作。

直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制

可能会导致`OutOfMemoryError`（服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常——即在计算内存大小的时候，忘记加上直接内存的量，而导致计算量 < 实际上使用量，已经超出物理内存限制）

### 2. HotSpot虚拟机的对象

主要关注在HotSpot上如何在Java堆中进行对象分配、布局和访问

#### （1）对象创建

从语言层面，只需要通过new这个关键词就能就创建了一个新对象。（这边对象是指普通的对象，而不包括数组、class对象）

对于底层来说需要经过很多步骤：

1. 首先进行类加载验证：JVM遇到一条字节码，发现是new指令，查看该指令参数能否在常量池中定位到一个类的符号引用（符号引用，就是用一组符号来描述所引用的目标，这边的符号引用就是代表一个类，[具体见](http://note.youdao.com/noteshare?id=eb547cdfc6c85c3c30ca9d0698c920d2&sub=3651306AE01B41B89750DF274F97A550#3)），并且检查该符号引用代表的类是否已经被加载、解析和初始化过。如果没有就执行类加载过程

2. 类加载验证之后，JVM为对象分配内存。**对象所需的内存大小在类加载完成后已经可以确定**，所以内存分配就是从Java堆中划分出一块确定大小的块给该对象

   划分时存在两种策略：

   - 如果堆内存是绝对规整的，即正在使用的放在一边，空闲的放在另一边。那么可以用**指针碰撞**，即在空闲和占用交界处存放一个指针——**分界指示器**，那么该划分就是指针向空闲方向移动指定大小——简单且高效
   - 如果堆内存不是绝对规整，即占用的内存块和空闲内存块混合，那么维护一个**空闲列表**，在空闲列表中找到一块足够大的空间划分给对象（如何找、如何划分、划分之后如何就是内存管理的问题了）

   => 这一块类似于DMA理论

   Java堆是否规整由**垃圾收集器是否带有空间压缩整理的能力**。使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞。CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存（为了优化性能，CMS会设计一个线性分配缓冲区，在空闲列表中拿到该缓冲区后，内部还是按照指针碰撞方式来分配）

   在分配内存的时候（是共享区域），涉及到线程安全的问题，那么也有两种策略保证线程安全：

   - 对分配内存空间的操作进行同步处理：采用CAS（乐观锁）的机制，保证更新操作的原子性

   - 在Java堆上给每个线程预先分配一小块内存：本地线程分配缓冲TLAB，线程就在自己的缓冲区上分配对象，只有TLAB分配完了，在分配新的缓冲区的时候用到同步锁

     （ps：虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。）

3. 分配内存完成后，将分配到的内存空间初始化为0（初始化不包括对象头）。如果使用TLAB，可以将初始化工作提前到TLAB的分配时。

   =>该步骤能保证，对象的实例字段**在Java代码中不需要初始化即可使用**（JVM已经给初始化了），能访问到都是0

4. 对对象进行必要的设置（主要是针对对象头）。包括：该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（初始的时候不会计算，到用到才会计算）、对象的GC分代年龄信息——存放在对象头（有点类似于DMA的块头信息）

   根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. JVM来说对象已经生成，但是还需要调用构造函数。Class文件中的<init>()方法还没有被执行——目前所有字段的值都是0，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。

   一般情况是，new指令之后会接着执行class<init>()方法——这是按照Java程序的需要进行初始化

   （ps：是否需要执行class<init>()，是由new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令（即new和invokespecial），但如果直接通过其他方式产生的则不一定如此）

——到这一步，真正可用的对象才算是被构造出来了

#### （2）对象内存布局

对象在内存中的布局划分为：对象头、实例数据、对齐填充

- 对象头：4B/8B

  - 1个字长（32位JVM就是32b长度，64位的就是64b长度），存储对象自身的运行时数据：如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

    ——称为“mark word”。

    要存储的运行时数据有很多，通常是超过了1word的长度的，但是为了空间效率，mark word被设计成有动态定义的数据结构，可以根据对象的状态复用存储空间

    ——即动态修改字长的存储内容的组合

  - 类型指针：指向它的类型元数据的指针，JVM通过该指针明确该对象是哪个类的实例

    （但是，不是所有JVM都要有类型指针，它们可以通过其他信息得到）

    **如果对象是数组，那么还需要在对象头存储数组长度**，$\because$ 对于普通对象可以通过类型信息知道对象的大小，而对于数组，必须通过显式给定，无法自行推断

- 实例数据：存储真正的有效信息，即在该类中定义的各类型字段的内容，包括从父类继承得到的，也包括独有的。

  **存储顺序会受到虚拟机分配策略**参数（-XX：FieldsAllocationStyle参数）**和字段在Java源码中定义顺序的影响**（即人为外部设定+定义时的顺序共同影响）

  Hotspot默认的分配顺序是：**先按照数据长度来分配顺序**：longs/doubles、ints、shorts/chars、bytes/booleans、oops，长的在前短的在后，且相同宽度的字段会被分配到一起；后按照父子类关系：**父类定义的变量会出现在子类之前**。

  如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。（空间压缩）

- 对齐填充：仅仅起占位符的作用。因为HotSpot的自动内存管理系统要求对象起始地址必须是8B的整数倍——所以每个对象的内存块都必须是8B的整数倍，如果实例数据不满足就通过占位符补齐

#### （3）对象访问定位

讲的是，当需要用对象的时候该如何找到它

Java程序会通过**栈**上的**reference数据**操作**堆**上的**具体对象**（类似于指针的效果，reference存放的是地址）

JVM规范规定了**reference类型只是一个指向对象的引用**，并没有定义该引用应该通过什么方式去定位等。主流的访问方式有2种：

- 句柄

  **Java堆**中会划分出一块内存来作为**句柄池**。reference存储的就是对象的句柄地址，而句柄包含了对象的实例数据和类型数据格子的地址信息。

  <img src="pic\image-20201221161525604.png" alt="image-20201221161525604" style="zoom:80%;" />

  即通过reference找到堆中的句柄池中对应的句柄地址；而句柄能够找到同堆中的对象实例；也能够找到方法区中的对象类型数据（该对象所属的类）

  ——不论访问对象本身or类型数据，都需要两次跳转

- 直接指针：

  reference直接存储对象的地址，但是如果需要找到该对象对应的类型数据，还需要通过对象头找到类型指针

  访问对象只需要一次跳转

  <img src="pic\image-20201221162234711.png" alt="image-20201221162234711" style="zoom:80%;" />

=> 两者的优缺点：

- 句柄访问，**reference存储的是稳定的句柄地址**，对象移动or其他情况发生，只需要修改句柄内容即可（在垃圾回收中会经常需要移动对象）
- 直接指针访问，速度快。只对对象访问只需要跳转一次——HotSpot的策略

### 3. OOM异常探索

（在书中，是直接对OpenJDK实践操作，但是需要大量空间且耗时较多，作为初学者打算就过一遍，了解如何触发这些异常即可）

能够在遇到OOM异常的时候，**能够知道内存溢出的位置以及何处代码可能触发该异常的**。

#### （1）堆溢出

堆是用来存储对象实例的，那么不断创建对象，并且存在引用避免回收，那么一定会出现OOM异常

——堆是最常见触发OOM的地方

异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”

如何解决该异常？

- 通过内存映像分析工具对Dump出来的堆转储快照进行分析

  分析是出现内存泄漏导致的内存溢出（对象应该死了，但是没有去释放该空间） or 单纯的是因为对象太多引起的内存溢出（对象确实都应该是存活的）

- 内存泄漏，通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们

- 内存溢出，检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

#### （2）虚拟机栈和本地方法栈溢出

HotSpot虚拟机的选择是不支持虚拟机栈的扩展，所以只会出现StackOverflowError异常，不会出现OOM异常（除非该线程在初始申请虚拟机栈的时候就因内存不够抛出OOM异常）

——如果想看在HotSpot上的OOM抛出OOM异常，可以创建很多线程，导致线程初始申请栈的时候就失败，从而抛出OOM异常（这个情况主要跟JVM虚拟机的内存大小有关了）

情况分析：

OS给每个进程分配的内存是有限制的，eg：32位Windows设置单线程的最大内存为2GB——意味着JVM能管理的最大内存为2GB，JVM在外部OS来看就是一个线程

2GB - 最大堆容量 - 最大方法区容量 - pc指针（很小）- 直接内存 - JVM本身消耗 = 虚拟机栈和本地方法栈可以使用的

ps：Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上，如果创建很多线程就容易给Windows造成大压力出现系统假死问题

给一个常识：如果使用HotSpot虚拟机默认参数，栈深度在大多数情况下1000~2000是不会出现溢出的（所以你写的递归程序出现栈溢出，说明递归无法结束）

栈的OOM溢出的处理：

如果是因为进程太多而导致的OOM，那么尝试减少线程数量、更换64位JVM，都不行的话，只能**减少最大堆和减少栈容量**来换取多线程

#### （3）方法区和运行时常量池溢出

方法区存放的是类的相关信息，例如类名、访问修饰符、常量池、字段描述、方法描述等

测试：运行时产生大量的类去填满方法区，直到溢出

当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。另外，很多运行于Java虚拟机上的动态语言（例如Groovy等）通常都会持续创建新类型来支撑语言的动态性——这种因为导入太多类而造成的OOM会越来越容易出现

——方法区也是触发OOM异常的常见地方

如果运行时需要生成大量动态类的应用场景，那么需要关注方法区的溢出情况。

#### （4）直接内存溢出

使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，它会通过计算去判断是否能够申请到内存，如果计算不能那就直接在代码中抛出异常，而不会去尝试申请

——真正申请分配内存的方法是Unsafe::allocateMemory()。

（由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了）:question::question::question:

## chap2 垃圾收集器和内存分配策略

GC技术历史久远，远在Java产生之前。垃圾收集需要考虑：

- **哪些内存需要回收**
- **什么时候回收**
- **如何回收**

why关注垃圾回收？

$\because$ 在各种内存溢出和内存泄漏问题出现时，需要从垃圾回收这个终点开始找是否是回收出现问题？

——对这些“自动化”的技术实施必要的监控和调节（因为这些不受我们控制，在出现问题时，才需要更加关注）







## ps：一些缩写等

JIT：just in time 即时编译器

AOT：ahead of  time compilation 提前编译（减少Java的预热时间，减少“第一次运行慢”的感觉）

Java SE：Java standard edition Java的标准版本

OOM：out of memory error，内存溢出异常

TLAB：Thread Local Allocation Buffer，线程私有的分配缓冲区

OOPs：Ordinary Object Pointers，传统对象指针

GC：Garbage Collection，垃圾收集