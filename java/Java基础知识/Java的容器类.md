# Java的容器类

这边主要介绍容器类的实现原理，至于具体实现，直接看源代码

# 1. 堆和优先队列

## 1.1 基本概念

堆首先是一棵二叉树，且**是完全二叉树**

（二叉树 -- 完全二叉树 -- 满二叉树，层层递进）

**完全二叉树的特性：给定任意一个节点，可以根据其编号直接快速计算出其父节点和孩子节点编号**（注意这个只是编号，而不是具体的值，编号是每一层从左向右开始给的编号）

**结点编号为i，则父结点编号为i/2，左孩子编号为2i，右孩子编号为2i+1（如果在数组中，从0开始的下标，那么左孩子是2i+1， 右孩子是2i+2，父结点为(i-1)/2）**

——**它使得逻辑概念上的二叉树可以方便地存储到数组中**，而父子关系可以隐藏在index中

总结：堆，是一个完全二叉树，物理上可以用数组存储。且**元素之间不是完全有序的，但是父子之间需要有一定的顺序**

优势：节省空间，访问效率高

分类：最大堆和最小堆

最大堆是指**每个节点都不大于其父节点**，所以根结点最大，而子树的树根就是整棵树里面的最大的。最小堆相反，根节点最小

## 1.2 基本操作

### 1.2.1 创建初始堆

就是将一个数组创建成一个堆（最小堆）

普通无序数组变为堆的过程称为heapify

思路：从最后一个**非叶子节点**开始，一直往前直到根，对每个节点，执行向下调整。即先构建一个小的最小堆，然后将前一个结点加入进来，然后对该结点进行调整，然后构成一个更大的堆

——自底向上，然后调整都是向下调整。

非叶子结点：size/2开始计算的。

### 1.2.2 增加元素

如果堆为空，那么添加的元素直接是根节点。

如果已经存在堆，要添加新的元素：（最小堆）

1. 添加元素到最后的位置
2. 与父结点进行比较，如果大于等于父结点，则不用移动；如果小于父结点，则和父结点进行交换，然后再以当前位置为起点，与新的父结点进行比较，直到到根节点或者满足父结点小于当前结点

eg：向如下堆添加一个3

<img src="../pic/priorityQueue_1.jpg" style="zoom:80%;" >

<img src="../pic/priorityQueue_2.jpg" style="zoom:80%;" >

然后3一路向上调整，最后成了根节点，是整个堆最小的结点。自底向上开始调整，称为向上调整

——所以时间复杂度，O(logN)，最多要遍历整个树高。

### 1.2.3 删除元素

这边特定是**删除堆头**（如果是非堆头，只是指定了具体的值，那么需要遍历整个堆）

流程：（最小堆）

1. 用最后一个元素替换堆头，并且删除最后一个元素（堆头已经被删除了）
2. 新的头部和两个结点进行比较，如果小于两个孩子（三个数里面，根节点最小），那么已经满足要求，不动；如果大于其中一个孩子（或者大于两个孩子），就挑孩子结点/较小的孩子结点进行交换，交换之后然后以此为新的起点，再次和新的孩子结点进行比较，直到叶子结点或者满足最小的情况

eg：删除堆头4

<img src="../pic/priorityQueue_3.jpg" style="zoom:80%;" >

最后的结果如下：

<img src="../pic/priorityQueue_4.jpg" style="zoom:80%;" >

如果删除的是中间节点，就是找到了要删除的结点，那么该如何删除呢？

1. 用最后一个结点替换要删除的结点，并将最后一个结点删除
2. 如果**该元素大于某个孩子结点，那么需要向下调整；如果该元素小于父结点，那么需要向上调整**

eg：向上调整：

<img src="../pic/priorityQueue_5.jpg" style="zoom:80%;" >

<img src="../pic/priorityQueue_6.jpg" style="zoom:80%;" >

向下调整：

<img src="../pic/priorityQueue_7.jpg" style="zoom:80%;" >

<img src="../pic/priorityQueue_8.jpg" style="zoom:80%;" >

### 1.2.4 查找和遍历

就是遍历数组，时间复杂度为O(N)

但是：如果是逐个从头部删除元素，那么堆可以确保输出是有序的。——每次都是取最小

## 1.3 优先队列

本质上就是用堆实现的。具体见源码阅读

# 2. Map和Set

Map常见的有：HashMap、

Set常见的有：

## 2.1 Map接口

Map有键和值的概念。一个键映射到一个值，Map按照键存储和访问值，**键不能重复**，即一个键只会存储一份，**给同一个键重复设值会覆盖原来的值**。

## 2.2 Set接口

数学中的集合概念，即**没有重复的元素集合**

它扩展了Collection，但没有定义任何新的方法，不过，它**要求所有实现者都必须确保Set的语义约束，即不能有重复元素**——概念上的限制。