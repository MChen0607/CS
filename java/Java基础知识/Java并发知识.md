# Java并发知识

根本：Java中所使用的并发机制依赖于**JVM的实现和CPU的指令**

# 1. Java并发机制的底层实现原理

## 1.1 volatile

和synchronized不同，volatile不是锁，而是**在多处理器开发中保证了共享变量的“可见性“**。

可见性：当一个线程去修改该变量时，另外一个线程能够读到该变化（并发存在的一个问题是，某个结点读取值之后被抢占了，而再次调度回来的时候，实际上值已经改变，而线程仍旧用原来的值，这个就是并发的问题）

### volatile的实现原理：

volatile的特性：如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

CPU的术语：（在技术博客中遇到过）：

<img src="../pic/cpu_word.jpg" style="zoom: 80%;" >

eg：

```java
volatile instance;
instance = new Singleton();
```

—— volatile修饰的变量被赋值，就是写操作。

转换为汇编：

```
0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: 
lock addl $0×0,(%esp);
```

下面一行`lock addl $0×0,(%esp);`有volatile变量修饰的共享变量进行写操作的时候会多出。

Lock前缀的指令在多核处理器下会引发了两件事：

- 将当前处理器缓存行的数据**写回到系统内存**（而不是暂时写在缓存行里，待适合的时机写回内存）
- 这个写回内存的操作会使**在其他CPU里缓存了该内存地址的数据无效**。

解释：

- 对于第一条：常规来说处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存，而**volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存**
- 对于第二条：如何确保缓存的同步性——为了保证各个处理器的缓存是一致的，就**会实现缓存一致性协议**，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

volatile的两条实现原则：

1. **Lock前缀指令会引起处理器缓存回写到内存**（内存独占式的）

   - 对于旧的CPU，Lock会**锁总线**，导致其他CPU不能访问总线，那么就不能访问内存，那么该CPU就独占内存——但是锁总线开销大
   - 在最近的处理器里，LOCK信号一般不锁总线，而是**锁缓存**。如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会**锁定这块内存区域的缓存并回写到内存**，并使用**缓存一致性机制来确保修改的原子性**，此操作被称为**“缓存锁定”**，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。——只锁部分区域，所以开销少

2. **一个处理器的缓存回写到内存会导致其他处理器的缓存无效**

   处理器使用**嗅探技术**保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。

   如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

eg：volatile的使用技巧：

JDK7中：LinkedTransferQueue，在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能

```java
/＊＊ 队列中的头部节点 ＊/
private transient final PaddedAtomicReference<QNode> head;
/＊＊ 队列中的尾部节点 ＊/
private transient final PaddedAtomicReference<QNode> tail;
static final class PaddedAtomicReference <T> extends AtomicReference <T> {
  //使用很多4个字节的引用追加到64个字节
  Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
  PaddedAtomicReference(T r) {
    super(r);
  }
}
public class AtomicReference <V> implements java.io.Serializable {
  private volatile V value;			// 4字节
  //省略其他代码
}
```

所以，PaddedAtomicReference对象，有64B。

英特尔酷睿i7等处理器，**缓存行是64个字节宽，不支持部分填充缓存行**。如果头尾都不足64字节的话，处理器会将它们都读到同一个高速缓存行中。所以如果需要修改，那么会将整个缓存行锁定，导致头尾结点均被锁定，而导致其他处理器不能访问自己高速缓存中的头尾结点了——降低了并发性。**追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。**

当然，这种字节填充也是有适用场景的，某些场景下是不适用的：

- 缓存行非64字节宽的处理器，某些是32位宽的等
- 共享变量不会被频繁地写，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。

## 1.2 synchronized的实现原理与应用

synchronized进行了各种优化之后，有些情况下它就并不那么重了

synchronized实现同步的基础：**Java中的每一个对象都可以作为锁**

有如下3种形式：

1. 对于普通同步方法，锁是**当前实例对象**
2. 对于静态同步方法，锁是当前类的**Class对象**
3. 对于同步方法块，锁是Synchonized**括号里配置的对象**

synchronized存在4种状态：无锁 -- 偏向锁 -- 轻量级锁 -- 重量级锁，会随着竞争情况进行升级，注意**只能升级不能降级**，即偏向锁升级为轻量级锁后不会变回偏向锁——目的是为了提高获得锁和释放锁的效率

### Java对象头

synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把**锁就是存在Java对象头**里的

对象是数组类型，则虚拟机用**3个字宽**（Word，1W=4B）**存储对象头，**如果对象是非数组类型，则用**2字宽存储对象头**。

<img src="../pic/java_head.jpg">

理解：

1. 第一个Word存放**标记字段**

   默认存储对象的HashCode、分代年龄和锁标记位

2. 第二个Word存放**类型指针**，向它的类元数据的指针，主要是用来告诉虚拟机**该对象是哪个类的实例**

3. 第个Word是数组特有的，记录数组长度，这就是为什么数组能够直接获取长度，arr.length——放在对象头里了

所以锁是存在于Mark-word的

默认的Mark-word存放如下内容：

<img src="../pic/default-head.jpg">

在运行期间，Mark Word里存储的数据会**随着锁标志位的变化而变化**。

<img src="../pic/state-head.jpg" style="zoom:80%;" >

<img src="../pic/state-head_64.jpg">

### Monitor

理解为一个同步工具或一种同步机制，通常被描述为一个对象。

因为：每一个Java对象就有一把看不见的锁，称为**内部锁或者Monitor锁**。——即对象带锁，如果存在并发操作该对象的情况，需要获取该锁。

而线程可能会访问很多共享对象，所以线程需要记录获得的这些对象和锁的信息——使用Monitor对象来存储

**Monitor是线程私有的数据结构**：monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

线程种monitor相关的：

- 每一个线程都有一个可用monitor record列表，存放Monitor对象，一个上锁的对象对应一个monitor对象
- 同时还有一个全局的可用列表

所以：synchronized通过Monitor来实现线程同步，**Monitor是依赖于底层的操作系统的互斥锁（是重量级锁）**来实现的线程同步。

### 锁的状态转换

4个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级**，目的是为了提高获得锁和释放锁的效率

#### 1. 无锁

没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

**CAS就是用无锁的思想实现的**（注意，不是无锁是CAS实现的，而是反过来的）

步骤：修改操作在循环内进行，线程会不断的尝试修改共享资源。多个线程同时修改该值，只有一个线程才能修改成功，而其他线程会不断尝试直到成功

无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

#### 2. 偏向锁

大部分情况下：锁不仅不存在多线程竞争，而且总是由**同一线程多次获得**。（但是还是存在并发的情况，所以还是需要锁的），所以为了**减少获取锁的代价**，提出偏向锁。

线程会自动获取锁，降低获取锁的代价。

步骤：当一个线程访问同步代码块并获取锁时，会在Mark Word里存储**锁偏向的线程ID**。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是**检测Mark Word里是否存储着指向当前线程的偏向锁**。

1. 如果标志字段存储当前线程ID，说明该线程已经获得过锁，那么可以再次进入（即，可能之前已经进入过一次临界区，然后执行完毕出去了，但是偏向锁不会主动放弃，还是指向它，那么需要再次进入时直接看MarkWord即可）
2. 如果检测失败，那么还需要看MarkWord的的偏向锁的标志：
   - 如果设置为1，表示是偏向锁，那么失败是由于其他线程已经占用该锁了，尝试使用**CAS将偏向锁指向当前线程**
   - 如果设置为0，表示是无锁，那么需要用CAS去竞争锁

——主要是由于在访问临界区时只需要简单的判断即可，而轻量级锁的获取和释放需要多次CAS原子操作。偏向锁只需要在**置换ThreadID的时候依赖一次CAS原子指令**即可。

##### 偏向锁的释放：

触发条件：偏向锁只有遇到其他线程**尝试竞争偏向锁**（即上面的2.1状态）时，持有偏向锁的线程才会释放锁，**线程不会主动释放偏向锁**（一旦持有，只有出现竞争才释放）

操作前提：需要等待全局安全点（在这个时间点上没有正在执行的字节码）

具体操作：

- 暂停拥有偏向锁的线程

- 检查持有偏向锁的线程是否活着：

  - 如果没有，将对象头设置成无锁状态，然后竞争的线程通过CAS竞争获得

  - 如果存活，看当前线程是否需要竞争锁（即仍然需要获取该锁）：

    - 如果需要竞争，那么升级为轻量级锁
    - 如果不需要竞争，那么另外一个线程获得偏向锁

    （Epoch表示该对象的偏向锁的撤销次数，如果次数>40，表示竞争次数过多，那么此对象不再适合用偏向锁，而下次再次撤销锁时，直接升级为偏向锁，而不进行判断是否需要竞争）

  如下图：

<img src="../pic/lock_race.png">

偏向锁在Java 6和Java 7里是默认启用的，可以手动关闭

#### 3. 轻量级锁

上面的，如果多个线程竞争获取偏向锁，就会自动升级为轻量级锁。其他线程会**通过自旋的形式尝试获取锁**，不会阻塞，从而提高性能。

##### 轻量级锁加锁

1. JVM会先在**当前线程的栈桢**中创建用于存储**锁记录**的空间，并将对象头中的Mark Word复制到锁记录中——官方称为Displaced MarkWord；

2. 线程尝试使用**CAS**将对象头中的Mark Word替换为指向锁记录的指针，并且将锁记录中的owner指向该对象的markword

   即互相指示：对象头的标志字段指向锁记录，而锁记录指向该标志字段

3. 如果成功，当前线程获得锁；

   如果失败，表示其他线程竞争锁，当前线程便尝试使用**自旋来获取锁。**

当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

##### 轻量级锁解锁

会使用原子的CAS操作将Displaced Mark Word替换回到对象头。

如果替换成功：表示没有竞争；

如果替换失败：存在竞争（另一个线程已经将轻量级锁升级到重量级锁，所以标志位变化了），那么说明存在竞争，释放锁，并且唤醒所有在等待的线程，重新开始竞争。

#### 4. 重量级锁

由于轻量级锁下的自旋时间过长（自旋会造成CPU的浪费），多个线程竞争锁，导致锁升级。

锁标志的状态值变为“10”，等待锁的线程都会进入**阻塞状态**

#### 5. 总结：

偏向锁通过对比Mark Word解决加锁问题，从而避免使用CAS，只有在变换偏向对象时需要用到CAS;

轻量级锁是通过用CAS操作（指向MarkWord的指针是用CAS获得的）和自旋（获得锁失败，就自旋等待）来解决加锁问题

重量级锁是将除了拥有锁的线程以外的线程都阻塞。

<img src="../pic/lock_advdis.jpg">

## 1.3 原子操作实现的基本原理

原子操作：不可被中断的一个或一系列操作。即即使出现并发情况也能保证结果的正确性。

<img src="../pic/atomic_base.jpg" style="zoom: 80%;" >

### 原子操作的实现

常用：基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作

而处理器会自动保证基本的内存操作的原子性，即读取或者写入一个字节就是原子的，即该cpu在操作该字节，而其他cpu是不能访问该字节所在的内存地址。

- 使用总线锁保证原子性：

  如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作，读取，改变值，写回），那么需要保证原子性就需要：锁定总线——

  使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以**独占共享内存。**——即锁定总线，导致整个CPU和整个内存的通信都锁定了

- 使用缓存锁保证原子性：

  总线锁定的开销比较大。

  频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行

  使用缓存锁定来保证原子性：内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定。当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址，并利用它的缓存一致性机制来保证操作的原子性。

  缓存一致性机制，某个CPU将缓存行写回后，会通知其他CPU对该内存地址的缓存无效，需要重新读取。