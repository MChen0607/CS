# Java特性相关

## 1. Java的优点

1. Java有3大特性：**封装、继承、多态**
2. **Java是平台无关性语言**——JVM保证，一次编译处处运行
3. 半解释半编译语言
4. 可靠性、安全性
5. （支持网络编程且很方便）

ps：

Java和c++的区别：

1. 均实现了封装继承多态
2. Java没有指针，程序内存更安全
3. Java有内存回收机制，所以不需要显式释放申请的内存
4. Java类是单继承、c++支持多继承；Java能通过接口实现多继承



## 2. 继承的实现



## 3. 多态的实现

（美团题）

多态的概念：程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定

- **编译时多态**

  重载就是编译时多态，在编译时就能确定

- **运行时多态**

  常见的多态就是运行时多态，直到运行时才能确定到底是哪个方法——**多态又被称为延迟方法**

多态常见有两种方法：

- 子类继承父类
- 类实现接口

虚拟机会在执行程序时动态调用实际类的方法，它会通过一种名为**动态绑定（又称延迟绑定）的机制自动实现**。

静态绑定 & 动态绑定：

JVM有5个方法调用的指令：

- `invokestatic`：调用静态方法
- `invokespecial`：调用实例构造器<init>方法、私有方法和父类方法
- **`invokevirtual`**：动态调用，调用虚方法
- **`invokeinterface`**：动态调用，调用接口方法，运行时才能确定调用哪个
- `invokedynamic`：运行时动态解析所使用的方法，然后再执行

`invokestatic\invokespecial`是静态绑定；`invokevirtual\invokeinterface`是动态绑定

虚拟机栈中会存放当前方法调用的栈帧，在栈帧中，存储着局部变量表、操作栈、动态连接 、返回地址和其他附加信息。

多态的实现过程，就是**方法调用动态分派的过程**，通过栈帧的信息去找到被调用方法的具体实现

invokevirtual在执行的时候：

1. **从操作栈中找到对象的实际类型class**

2. 然后找到在class中和被调用的方法一致的方法，如果有权限访问那么就返回该方法；如果没有权限就报错java.lang.IllegalAccessError

   （子类在重写父类方法时候，权限不能比父类小）

3. 如果没有找到，那么就在父类中找，再次执行步骤2，自下而上去找该方法

4. 如果直到最上层的父类都找不到该方法，那么报错java.lang.AbstractMethodError 

所以，可以发现在动态绑定中首先会去确定对象的实际类型，去找该class中对应的方法，所以动态绑定优先绑定子类方法。

实际上，商用虚拟机为了保证性能，通常会使用虚方法表和接口方法表，而不是每次都执行一遍上面的步骤。以虚方法表为例，**虚方法表在类加载的解析阶段填充完成**，其中存储了所有方法的直接引用。也就是说，动态分派在填充虚方法表的时候就已经完成了。在子类的虚方法表中，如果子类覆盖了父类的某个方法，则这个方法的直接引用指向子类的实现；而子类没有覆盖的那些方法，比如 Object 的方法，直接引用指向父类或 Object 的实现。

## 4. 类加载机制

类在程序运行过程中进行加载、连接的，会增加开销，但是灵活性提高。

**类的生命周期：7个阶段。**

类的加载时机：没有规定；

类的初始化时机：5个主动初始化的时机——主动引用；其余都不会触发初始化——被动引用

类的加载过程：5步具体的任务

- 加载：3件事：通过类的全限定名获得该类的二进制字节流 -> 将字节流代表的静态存储结构转换为方法区中的运行时数据结构 -> 方法区中生成一个代表该类的java.lang.class对象，是访问该类的入口
- 验证：4个验证：文件格式验证（字节流）、元数据验证、字节码验证（语义合法）、符号引用验证（动作可执行性）
- 准备：给类变量分配空间，并给初始值——方法区中；对应静态常量，会给指定的值——常量池中
- 解析：常量池中的符号引用替换为直接引用；解析动作
- 初始化：正式开始执行代码，执行类构造器<clinit>方法，是隐式进行调用且不一定会有该步骤，同一个类只会被初始化一次，JVM保证并发执行的正确性（有且仅有一个线程能够进行该类的初始化，其他的均要阻塞等待

注意：类能够在初始化完成之前创建实例对象

具体见：[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART1.md#2-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)

## 5. 类实例化

实例化之前必须要被正确的初始化（如果在初始化时遇到了实例化，那么会先去执行实例化）

对象的创建时机：4个

创建过程：分配内存（堆中）；初始化：实例变量 & 实例代码块初始化，构造方法初始化（会调用父类的构造方法 or 调用重载构造方法）

——创建对象的整个流程：**父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数（两者可以整合成父类构造方法） -> 子类的成员变量和实例代码块 -> 子类的构造函数（两者也可以整合）**

具体见：[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART1.md#3-java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)

## 6. Java的缩写：JVM & JRE & JDK

### 6.1 JVM

JVM是Java虚拟机，能够运行Java字节码（.class文件），JVM是按照不同的操作系统的具体实现，而**Java是平台无关性，主要就是靠JVM来实现该特性的**。

字节码不面向任何处理器，只是针对JVM。

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210411144754796.png" alt="image-20210411144754796" style="zoom: 67%;" />

从Java源代码到机器码运行有3步：先通过javac对源代码进行编译，生成.class文件——就是JVM能够识别的字节码文件，然后JVM加载字节码文件（就是前面的类加载机制），**边解释边运行**，解释成平台相关的机器指令然后计算机执行，所以速度比直接生成机器码的语言运行起来要慢。

引入了JIT编译器，是运行时编译器，在完成编译后，会将字节码对应的机器码保存下来，下一次运行时直接使用机器码运行而不是再次编译。

**Hotspot使用惰性评估，根据二八定律**，经常运行的只有那小部分代码，所以JVM每次会根据运行情况做出优化，执⾏的次数越多，它的速度就越快。JDK引⼊了⼀种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码。

### 6.2 JDK &JRE

JDK：Java开发工具包，包含有JRE，还有编译器javac和工具javadoc、jdb。**能够创建和编译程序**

JRE：Java运行时环境，能够运行已经编译的Java程序所需要的内容，包括：JVM、Java类库、Java命令和其他基础构件。**只能运行，不能创建、编译程序**

## 7. Java字符串不需要结束符

在学c的时候，字符串、字符数组会被默认在后面加上`\0`，表示该字符串、字符数组的结束，但是Java没有这个结束符的概念。

对于C语言，字符串和字符数组本质上是一个东西，本质上都是存储在字符数组中的（Java也是）。

`char arr[5] = {'1', '2', '3', '4'};`，会在最后加上一个`\0`，其实这个`\0`就是用来表示字符串结束，后面的内容不需要再考虑了，所以`\0`就是用来方便计算字符串长度、输出等操作的。

**Java里面一切都是对象，字符串含有长度属性**，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了

## 8. 字符常量和字符串常量的区别

1. 字符常量：只有一个字符，用单引号；字符串常量：有多个字符，用多引号
2. 字符常量：能够转换成整型数字，可以定位到ASCII表中的位置，并且参与运算；字符串常量不行，它代表的是一个地址，能够通过该地址找到字符串常量的存放的位置
3. 字符常量：占据2字节内存；字符串常量本质上是字符数组，占据多个字节（数组 + 属性内容，本质上是对象）

ps：**Java的基本数据类型长度的不变性**，能够提高移植性。

## 9. 重载和重写

重载：在一个类中，同方法名的方法，其参数列表、返回值等可以存在不同，编译器会根据传参来确定调用哪个方法——编译时多态（在编译时就能确定）

重写：父子类之间，子类继承了父类的方法，然后重写了里面的逻辑，但是方法的名字、返回值、参数列表均没有发生变化。但是，异常的范围要小于父类、访问权限不能小于父类。存在**运行时多态**。**private/final/static修饰的方法不能被重写**，但是static方法可以被重新声明（实际上static方法是类方法，所以不存在重写的说法）

具体见：[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART2.md#3-%E9%87%8D%E8%BD%BD--%E9%87%8D%E5%86%99)