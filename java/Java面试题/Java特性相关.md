# Java特性相关

## 1. Java的优点（4点）

1. Java有3大特性：**封装、继承、多态**
2. **Java是平台无关性语言**——JVM保证，一次编译处处运行
3. 半解释半编译语言
4. 可靠性、安全性
5. （支持网络编程且很方便）

ps：

### Java和c++的区别：（4点）

1. 均实现了封装继承多态
2. Java没有指针，程序内存更安全
3. Java有内存回收机制，所以不需要显式释放申请的内存
4. Java类是单继承、c++支持多继承；Java能通过接口实现多继承

## 2. 继承的实现

继承：在内存上，子类能够继承父类的所有方法，但是对于私有方法无法访问；从概念上，子类能够继承父类的public、protected方法和属性，但是不能继承private方法。

## 3. 多态的实现

（美团题）

多态的概念：程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定

- **编译时多态**

  重载就是编译时多态，在编译时就能确定

- **运行时多态**

  常见的多态就是运行时多态，直到运行时才能确定到底是哪个方法——**多态又被称为延迟方法**

多态常见有两种方法：

- 子类继承父类
- 类实现接口

虚拟机会在执行程序时动态调用实际类的方法，它会通过一种名为**动态绑定（又称延迟绑定）的机制自动实现**。

静态绑定 & 动态绑定：

JVM有5个方法调用的指令：

- `invokestatic`：调用静态方法
- `invokespecial`：调用实例构造器<init>方法、私有方法和父类方法
- **`invokevirtual`**：动态调用，调用虚方法
- **`invokeinterface`**：动态调用，调用接口方法，运行时才能确定调用哪个
- `invokedynamic`：运行时动态解析所使用的方法，然后再执行

`invokestatic\invokespecial`是静态绑定；`invokevirtual\invokeinterface`是动态绑定

虚拟机栈中会存放当前方法调用的栈帧，在栈帧中，存储着局部变量表、操作栈、动态连接 、返回地址和其他附加信息。

多态的实现过程，就是**方法调用动态分派的过程**，通过栈帧的信息去找到被调用方法的具体实现

invokevirtual在执行的时候：

1. **从操作栈中找到对象的实际类型class**

2. 然后找到在class中和被调用的方法一致的方法，如果有权限访问那么就返回该方法；如果没有权限就报错java.lang.IllegalAccessError

   （子类在重写父类方法时候，权限不能比父类小，如果子类没法访问那么父类也没法访问）

3. 如果没有找到，那么就在父类中找，再次执行步骤2，自下而上去找该方法

4. 如果直到最上层的父类都找不到该方法，那么报错java.lang.AbstractMethodError 

所以，可以发现在动态绑定中首先会去确定对象的实际类型，去找该class中对应的方法，所以动态绑定优先绑定子类方法。

实际上，商用虚拟机为了保证性能，通常会使用虚方法表和接口方法表，而不是每次都执行一遍上面的步骤。以虚方法表为例，**虚方法表在类加载的解析阶段填充完成**，其中存储了所有方法的直接引用。也就是说，动态分派在填充虚方法表的时候就已经完成了。在子类的虚方法表中，如果子类覆盖了父类的某个方法，则这个方法的直接引用指向子类的实现；而子类没有覆盖的那些方法，比如 Object 的方法，直接引用指向父类或 Object 的实现。

## 4. 类加载机制

类在程序运行过程中进行加载、连接的，会增加开销，但是灵活性提高。

### 类的生命周期：

**7个阶段。**

### 类的加载时机：

没有规定；

### 类的初始化时机：

5个主动初始化的时机——主动引用；其余都不会触发初始化——被动引用

### 类的加载过程：5步具体的任务

- 加载：3件事：通过类的全限定名获得该类的二进制字节流 -> 将字节流代表的静态存储结构转换为方法区中的运行时数据结构 -> 方法区中生成一个代表该类的java.lang.class对象，是访问该类的入口
- 验证：4个验证：文件格式验证（字节流）、元数据验证、字节码验证（语义合法）、符号引用验证（动作可执行性）
- 准备：给类变量分配空间，并给初始值——方法区中；对应静态常量，会给指定的值——常量池中
- 解析：常量池中的符号引用替换为直接引用；解析动作
- 初始化：正式开始执行代码，执行**类构造器<clinit>方法**，是隐式进行调用且不一定会有该步骤，同一个类只会被初始化一次，JVM保证并发执行的正确性（有且仅有一个线程能够进行该类的初始化，其他的均要阻塞等待

注意：类能够在初始化完成之前创建实例对象

具体见：[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART1.md#2-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)

## 5. 类实例化

实例化之前必须要被正确的初始化（如果在初始化时遇到了实例化，那么会先去执行实例化）

### 对象的创建时机：4个

创建过程：

- 分配内存（堆中）；
- 初始化：实例变量 & 实例代码块初始化，构造方法初始化（会调用父类的构造方法 or 调用重载构造方法）

——创建对象的整个流程：**父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数（两者可以整合成父类构造方法） -> 子类的成员变量和实例代码块 -> 子类的构造函数（两者也可以整合）**

具体见：[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART1.md#3-java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)

## 6. Java的缩写：JVM & JRE & JDK

### 6.1 JVM

JVM是Java虚拟机，能够运行Java字节码（.class文件），JVM是按照不同的操作系统的具体实现，而**Java是平台无关性，主要就是靠JVM来实现该特性的**。

字节码不面向任何处理器，只是针对JVM。

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210411144754796.png" alt="image-20210411144754796" style="zoom: 67%;" />

#### 从Java源代码到机器码运行有3步：

1. 先通过javac对源代码进行编译，生成.class文件——就是JVM能够识别的字节码文件
2. 然后JVM加载字节码文件（就是前面的类加载机制），**边解释边运行**，解释成平台相关的机器指令然后计算机执行，所以速度比直接生成机器码的语言运行起来要慢。

#### 引入了JIT编译

是运行时编译器，在完成编译后，**会将字节码对应的机器码保存下来**，下一次运行时直接使用机器码运行而不是再次编译。

**Hotspot使用惰性评估，根据二八定律**，经常运行的只有那小部分代码，所以JVM每次会根据运行情况做出优化，执⾏的次数越多，它的速度就越快。JDK9引⼊了⼀种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码。

### 6.2 JDK &JRE

JDK：Java开发工具包，包含有JRE，还有编译器javac和工具javadoc、jdb。**能够创建和编译程序**

JRE：Java运行时环境，能够运行已经编译的Java程序所需要的内容，包括：JVM、Java类库、Java命令和其他基础构件。**只能运行，不能创建、编译程序**

## 7. Java字符串不需要结束符？

在学c的时候，字符串、字符数组会被默认在后面加上`\0`，表示该字符串、字符数组的结束，但是Java没有这个结束符的概念。

对于C语言，字符串和字符数组本质上是一个东西，本质上都是存储在字符数组中的（Java也是）。

`char arr[5] = {'1', '2', '3', '4'};`，会在最后加上一个`\0`，其实这个`\0`就是用来表示字符串结束，后面的内容不需要再考虑了，所以`\0`就是用来方便计算字符串长度、输出等操作的。

**Java里面一切都是对象，字符串含有长度属性**，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了

## 8. 字符常量和字符串常量的区别

1. 字符常量：只有一个字符，用单引号；字符串常量：有多个字符，用多引号
2. 字符常量：能够转换成整型数字，可以定位到ASCII表中的位置，并且参与运算；字符串常量不行，它代表的是一个地址，能够通过该地址找到字符串常量的存放的位置
3. 字符常量：占据2字节内存；字符串常量本质上是字符数组，占据多个字节（数组 + 属性内容，本质上是对象）

ps：**Java的基本数据类型长度的不变性**，能够提高移植性。

## 9. 重载和重写

重载：在一个类中，同方法名的方法，其参数列表、返回值等可以存在不同，编译器会根据传参来确定调用哪个方法——编译时多态（在编译时就能确定）

重写：父子类之间，子类继承了父类的方法，然后重写了里面的逻辑，但是方法的名字、返回值、参数列表均没有发生变化。但是，异常的范围要小于父类、访问权限不能小于父类。存在**运行时多态**。**private/final/static修饰的方法不能被重写**，但是static方法可以被重新声明（实际上static方法是类方法，所以不存在重写的说法）

具体见：[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART2.md#3-%E9%87%8D%E8%BD%BD--%E9%87%8D%E5%86%99)

## 10. Java面向对象的三个特性

面向对象的三个特性：封装、继承、多态

封装：是通过改变方法、变量的可见性实现的。

​			概念：通过将类的一些属性私有化，而又提供一些方法能访问该属性，而如果某些类型不想被访问，那么就不给方法访问即可

继承：子类需要继承父类的方法，并且在该方法上进行扩展

多态：程序中引用变量所指向的具体类型和该类型调用的方法在编译时不可确定，只有在具体运行时才能确定。多态的两种实现方法：继承、接口

## 11. String、StringBuilder、StringBuffer区别

### 可变性：

1. String的内部：是final修饰的char类型的数组`private final char[] value;`，所以是不可变的，而我们使用的赋值`s = "helloword"`，其本质是创建了一个新的string对象；

   ps：底层的数组修改为byte[]数组，主要是更省空间，如果是UTF-16编码，那么就数组长度就是字符串长度的两倍

2. StringBuilder、StringBuffer的内部：没有final修饰的char类型的数组，`char[] value;`

### 线程安全：

1. String由于是不可变的，是常量，所以是线程安全的
2. StringBuffer加了同步锁`synchronized`，所以是线程安全的，性能变差
3. StringBuilder是非线程安全的，但是性能更好

### 扩容：

1. 由于String不可变，所以如果要改变时，都会创建一个新的String对象，然后将引用变量指向该对象。
2. StringBuilder、StringBuffer可变，默认长度为16，扩容为**2*len+2**

## 12. 自动装箱和拆箱

- 装箱：基本数据类型 -> 引用数据类型，`Integer.valueOf(10)`
- 拆箱：引用数据类型 -> 基本数据类型，`xxx.intValue()`

实现了自动的装箱和拆箱操作，即自动调用了`valueOf`和`intValue`的方法。

注意有存在缓存的情况，具体见[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%BA%90%E7%A0%81%EF%BC%88Integer%E9%87%8D%E7%82%B9%EF%BC%89(%E5%AE%8C).md#4-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95valueof--%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95xxxvalue)

如果有操作数是表达式（即包含算术运算），则比较的是数值（即会触发自动拆箱的过程）。

## 13. 定义一个没有内容且没有参数的构造方法的作用

即空构造方法`public Base(){}`，没有内容、没有参数。

如果一个类中，没有任何构造方法，则编译器会自动创建一个这样的构造方法；而如果有自定义一个构造方法，则编译器不会再构造；

该空构造方法的作用：**用在子类继承上**。存在这样的情况：子类的构造方法中没有显式的调用父类的构造方法，则编译器会默认加上`super()`，而父类只有自定义的带参的构造方法，所以`super()`就找不到默认的构造方法了，会出现编译错误。所以为了防止出错，所以在父类中创建一个空的构造方法。

## 14. import java 和 javax 有什么区别

javax开始是扩展的API包，后面javax也变成了Java的基础包之一。

## 15. 接口和抽象类的区别是什么

接口：表示

抽象类：

## 16. 局部变量和成员变量的区别

1. 成员变量：属于类的，可以被访问修饰符修饰；局部变量：属于方法 or 属于代码段，不能设置可见性
2. 成员变量：如果是静态变量，则存储在方法区中；常量存储在常量池中；如果是实例变量，则和对象一起存储在堆内存中；局部变量：如果是基本数据类型，则存储在栈中；如果是引用数据类型，对象存储在堆内存中，引用变量存储在栈中
3. 成员变量：随着对象的创建而存在；局部变量：随着方法的执行而存在，方法、代码段执行完成就消亡了
4. 成员变量：会被自动赋一个初值，**final也还是需要赋值的**；局部变量：显式赋值

## 17. ==和equals

具体见[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%BA%90%E7%A0%81%EF%BC%88Integer%E9%87%8D%E7%82%B9%EF%BC%89(%E5%AE%8C).md#1-equals%E5%92%8C%E7%9A%84%E6%AF%94%E8%BE%83)

### 不用写equals的场景

1. 类的实例是唯一的
2. 不关心是否实现了equals方法
3. 超类已经实现了equals方法，只需要继承
4. 该类是private的方法，所以实际上是不能用调用private

## 18. equals和hashCode的关系

具体见[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%BA%90%E7%A0%81%EF%BC%88Integer%E9%87%8D%E7%82%B9%EF%BC%89(%E5%AE%8C).md#3-equals%E5%92%8Chashcode)

hashCode只有在哈希表等地方才用到，其他地方用不到。

## 19. Java只有值传递

C语言也是。

- **Java不能在方法中修改一个基本数据类型变量的值**，即方法返回后，该变量的值没有发生变化
- Java能修改对象的内部状态，例如数组，可以修改数组里面的值；例如对象，可以修改对象里面的属性值
- **Java不能在方法中让一个引用变量指向另一个对象**，即方法返回后，该引用变量还是指向了那个对象

## 20. Java中线程的状态（6个）

和OS有所区别：

- new状态：还未调用start方法
- runnable状态：包括运行态和就绪态
- blocked状态：进程阻塞于锁
- waiting状态：进程等待其他进程唤醒
- time_waiting状态：超时等待
- terminated：结束状态

具体见[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86.md#314-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81)

## 21. final关键字

final可以修饰变量、方法、类

### 使用final方法的原因：



具体见[文档](https://github.com/amyZhoucc/CS/blob/main/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1PART2.md#5-final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%80%BB%E7%BB%93)

## 22. 异常处理

异常有一个父类：Throwable，有两个大子类：

- Error、Exception，Error是指错误，一般不是程序能够控制的，而是JVM内部出现了错误，有内存溢出异常、栈溢出异常等
- Exception是异常，很多时候都是程序不当造成的，有一个重要的子类：`RuntimeException`，由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引⽤任何对象时，抛出该异常）、ArithmeticException（算术运算异常，⼀个整数除以0 时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）

——Exception能被程序本身处理，而Error不能。

## 23. Java 序列化中如果有些字段不想进行序列化，怎么办



## 24. 获取用键盘输入常见的两种方法

用scanner类

```java
Scanner input = new Scanner(System.in); 
String  s = input.nextLine(); 
input.close();
```

用BufferedReader类

```java
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();
```

## 25. IO流

