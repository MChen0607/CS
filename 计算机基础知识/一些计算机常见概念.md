# 目录
1. [内存泄漏](#1)
2. [回调函数](#2)
3. [Java的字面量&符号引用&直接引用](#3)
4. [Unicode了解](#4)
5. [大端和小端](#5)

## 1. 内存泄漏问题

<a name="1"></a>

由于疏忽或者错误，导致没有释放该释放的内存，就是**在释放之前就失去了对该段内存的控制，从而造成的内存浪费**——Wiki

对于Java来说，申请的空间**没有被正确释放**（想放但是失败了/忘记释放），而后续的程序认为该内存被占用（不可达），而指向该内存段的指针不存在了，那么该内存块永远不可达了——总的可用内存块就相应变少了，如果出现频繁的话，就会导致内存资源不够的情况

对比**内存溢出**的情况

#### 内存溢出（OOM, out of memory）

常见的就是栈溢出；缓冲区溢出。栈溢出：就是在栈空间内分配了超过其长度的内存，而导致多出来的数据覆盖了栈空间其他位置的数据——eg：pintos的栈和线程数据结构存放在同一page中，线程从低位开始向高位增长；栈从高位开始向低位增长，如果栈溢出了，就会将线程数据结构中的数据覆盖掉——所以设置了一个脏位——来标记是否发生溢出

内存溢出原因：

1. 内存中**加载的数据量过于庞大**，如一次从数据库取出过多数据；
2. 集合类中有对对象的引用，**使用完后未清空**，使得JVM不能回收；
3. 代码中存在**死循环或循环产生过多重复的对象实体**；
4. 使用的**第三方软件中的BUG**；
5. 启动参数**内存值设定的过小**

内存泄漏最后也会会导致内存溢出

## 2. 回调函数概念

<a name="2"></a>

### 定义

首先了解一点：编程分为：

- 系统编程：编写库。而系统编程完成之后会给库留下接口API，给下面的应用程序中使用

- 应用编程：调用写好的库来编写有某种功能的程序——就是应用程序

所以，库就位于底层，而应用就位于上层，更贴近人类使用

=> 程序运行时，一般是应用程序会调用库API来实现某些功能，而有些库API会要求**传递的参数是一个函数**，从而在该API的某个位置调用该函数实现某个目标（一般这个函数是应用层面实现的）

——这个被当成参数传递（**登记回调函数**），而后又被调用的函数就是回调函数

所以一般的操作是：应用程序 --*调用*--> 库API --*返回*-->应用程序
而回调函数中：应用程序 --*调用*--> 库API --*调用*--> 应用程序（other）--*返回*--> 库API --*返回*--> 应用程序

如下图：
<img src="https://pic2.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_1440w.jpg?source=1940ef5c" alt="example">
（回调函数和应用程序常处于同一层，所以就出现了高层调用底层，底层**回头调用**高层）

eg：pintos的`timer_handler`调用的`foreach`函数中就是使用了回调函数，我们自己实现在遍历函数中要对哪些线程进行如何操作。如果传递的回调函数不一样，结果也是不同的

### 优势

回调机制灵活性大，因为在应用程序调用API的时候，通过登记不同的回调函数，API实现的效果也是不同的。这个比简单的函数调用灵活很多

ps：回调函数还分为：
- 阻塞式回调：回调函数的调用发生在返回到原应用函数之前（一般在单线程下，线性运行）

- 延迟式回调：回调函数的调用发生可能发生在原应用函数返回之后（可能是多线程的情况下进行的）

## 3. 字面量&符号引用&直接引用

<a name="3"></a>

字面量：源代码中固定值的表示

eg：`int i = 1;` 其中1就是字面量

   `String s = "abc";`其中"abc"就是字面量

符号引用：就是字符串，用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可

eg：`org.test.People`类引用了`org.test.Language`类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号`org.test.Language`来表示Language类的地址。

直接引用：

1. 直接指向目标的指针
2. 相对偏移量
3. 一个间接定位到对象的句柄 

## 4. Unicode了解

<a name="4"></a>

Unicode称为统一码、万国码，它是计算机领域的一项业界标准。主要是，为**世界上每一个字符都分配了一个编号**。编号范围为：`0x000000 ~ 0x10FFFF`，在`0x000000~0x00FFFF`范围内的字符被称为**常用字符集**（65536个常用字符），BMP。在`0x010000~`被称为**增补字符集**。

=>主要规定了编号，没有规定如何将编号映射成二进制的表示。

**UTF-16**就是一种编码方式，它将编号映射为2个或者4个字节（16/32位），对于**常用字符集**，用两个字节表示；增补字符集用4个字节表示：前2个字节叫做高代理项，后2个字节叫做低代理项

——UTF-16定义了一个公式，可以将编号和4字节表示相互转换。

Java内部就是采用UTF-16编码。char就是一个字符（2个字节），但是只能表示BMP；而对于增补字符集，需要用2个char表示

int可以表示任意一个Unicode字符，用低21位表示，其余高11位设置为0。**整数编号在Unicode中称为代码点code point**——代表一个Unicode字符；**代码单元，表示一个char**

=>Unicode还给字符分配了一些属性

## 5. 大端 & 小端

- **大端字节序**：高位字节在前，低位字节在后——即高位字节先出现，低位字节后出现，符合人们日常读数：先读最高位后向下读

  eg: 0x123456, 12 存放在低字节处，56存放在最高字节处。

- **小端字节序**：低位字节在前，高位字节在后

  正好相反。

大端序方便人类查看，因为习惯从最高位开始看起；小端序方便机器处理，因为机器习惯从低位开始处理

——**只有读取的时候，才必须区分字节序，其他都是看成字节流**

大端序的读取：`x = buf[offset] << 8 + buf[offset+1];`

小端序的读取：`x = buf[offset+1] << 8 + buf[offset];`

## 6. C语言的编译过程（pdd三面）

预处理 -> 编译 -> 汇编 -> 链接

## 7. 面向对象 & 面向过程（pdd三面）



参考：https://blog.csdn.net/jerry11112/article/details/79027834

## 8. 编译型语言 & 解释型语言（pdd三面）

背景：现在的编程语言都是人类语言，就是用人类方便记忆的方式进行编写的，但是计算机并不能识别，**计算机只能识别二进制指令**。所以需要将源代码转换成二进制指令。

### 概念

根据**何时将源代码转换成二进制指令**，不同编程语言有不同的规定：

1. 编译型语言：先将源代码转换成二进制指令，生成一个可执行文件，eg：.exe，.out等，然后再执行该可执行文件

   eg：c、c++、go

   它们的转换工具是编译器

   翻译源码的大致步骤：词法分析、语法分析、语义分析、性能优化、生成可执行文件等五个步骤

2. 解释型语言：边执行边转换，需要哪些就转换哪些源码，不会生成可执行文件

   eg：python、Java、shell

   它们的转换工具是解释器

### 特点和区别

编译型语言：一旦在该平台下生成可执行文件，只要不修改源码，那么就能直接使用可执行文件运行，运行效率高——一次**编译**处处运行（在同一个机器中）

——**编译型语言可以脱离开发环境运行**，可以实现闭源

——**编译型语言不能跨平台**：

- 可执行文件不能跨平台（底层指令架构等都不一样）；
- 源代码不能跨平台，例如库方法、类型等不同，eg：c语言的在 Windows 平台下该函数是 Sleep()，在 Linux 平台下该函数是 sleep()，首字母大小写不同，且设置的时间前者是毫秒为单位，后者是秒为单位。Windows 64 位平台下的 long 占用 4 个字节，Linux 64 位平台下的 long 占用 8 个字节

解释型语言：每次执行都需要将源代码逐步转换成二进制代码，效率较低

——**无法脱离开发环境**

——**一次==编写==处处运行**（在不同机器之间），跨平台性好

主要由于：解释器，解释器是不能跨平台的，针对不同平台开发不同的解释器，而解释器对上屏蔽了底层机器的差异性——**解释器就是中间层**

### 解释型语言存在的意义

对于不追求性能的场景，例如某个小型网站等，解释型语言可以加快开发。由于支持跨平台，那么只要编写一套代码即可，如果是编译型语言，那么要出很多针对不同架构、操作系统的版本

——**牺牲性能去换取编写的方便**

