## 目录
1. [内存泄漏](#1)
2. [回调函数](#2)
3. [Java的字面量&符号引用&直接引用](#3)
4. [Unicode了解](#4)
5. [大端和小端](#5)

## 1. 内存泄漏问题

<a name="1"></a>

由于疏忽或者错误，导致没有释放该释放的内存，就是**在释放之前就失去了对该段内存的控制，从而造成的内存浪费**——Wiki

对于Java来说，申请的空间**没有被正确释放**（想放但是失败了/忘记释放），而后续的程序认为该内存被占用（不可达），而指向该内存段的指针不存在了，那么该内存块永远不可达了——总的可用内存块就相应变少了，如果出现频繁的话，就会导致内存资源不够的情况

对比**内存溢出**的情况

#### 内存溢出（OOM, out of memory）

常见的就是栈溢出；缓冲区溢出。栈溢出：就是在栈空间内分配了超过其长度的内存，而导致多出来的数据覆盖了栈空间其他位置的数据——eg：pintos的栈和线程数据结构存放在同一page中，线程从低位开始向高位增长；栈从高位开始向低位增长，如果栈溢出了，就会将线程数据结构中的数据覆盖掉——所以设置了一个脏位——来标记是否发生溢出

内存溢出原因：

1. 内存中**加载的数据量过于庞大**，如一次从数据库取出过多数据；
2. 集合类中有对对象的引用，**使用完后未清空**，使得JVM不能回收；
3. 代码中存在**死循环或循环产生过多重复的对象实体**；
4. 使用的**第三方软件中的BUG**；
5. 启动参数**内存值设定的过小**

内存泄漏最后会导致内存溢出

## 2. 回调函数概念<a name="2"></a>

### 定义

首先了解一点：编程分为：

- 系统编程：编写库。而系统编程完成之后会给库留下接口API，给下面的应用程序中使用

- 应用编程：调用写好的库来编写有某种功能的程序——就是应用程序

所以，库就位于底层，而应用就位于上层，更贴近人类使用

=> 程序运行时，一般是应用程序会调用库API来实现某些功能，而有些库API会要求**传递的参数是一个函数**，从而在该API的某个位置调用该函数实现某个目标（一般这个函数是应用层面实现的）

——这个被当成参数传递（**登记回调函数**），而后又被调用的函数就是回调函数

所以一般的操作是：应用程序 --*调用*--> 库API --*返回*-->应用程序
而回调函数中：应用程序 --*调用*--> 库API --*调用*--> 应用程序（other）--*返回*--> 库API --*返回*--> 应用程序

如下图：
<img src="https://pic2.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_1440w.jpg?source=1940ef5c" alt="example">
（回调函数和应用程序常处于同一层，所以就出现了高层调用底层，底层**回头调用**高层）

eg：pintos的`timer_handler`调用的`foreach`函数中就是使用了回调函数，我们自己实现在遍历函数中要对哪些线程进行如何操作。如果传递的回调函数不一样，结果也是不同的

### 优势

回调机制灵活性大，因为在应用程序调用API的时候，通过登记不同的回调函数，API实现的效果也是不同的。这个比简单的函数调用灵活很多

ps：回调函数还分为：
- 阻塞式回调：回调函数的调用发生在返回到原应用函数之前（一般在单线程下，线性运行）

- 延迟式回调：回调函数的调用发生可能发生在原应用函数返回之后（可能是多线程的情况下进行的）

## 3. 字面量&符号引用&直接引用

<a name="3"></a>

字面量：源代码中固定值的表示

eg：`int i = 1;` 其中1就是字面量

   `String s = "abc";`其中"abc"就是字面量

符号引用：就是字符串，用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可

eg：`org.test.People`类引用了`org.test.Language`类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号`org.test.Language`来表示Language类的地址。

直接引用：

1. 直接指向目标的指针
2. 相对偏移量
3. 一个间接定位到对象的句柄 

# 4. Unicode了解

<a name="4"></a>

Unicode称为统一码、万国码，它是计算机领域的一项业界标准。主要是，为**世界上每一个字符都分配了一个编号**。编号范围为：`0x000000 ~ 0x10FFFF`，在`0x000000~0x00FFFF`范围内的字符被称为**常用字符集**（65536个常用字符），BMP。在`0x010000~`被称为**增补字符集**。

=>主要规定了编号，没有规定如何将编号映射成二进制的表示。

**UTF-16**就是一种编码方式，它将编号映射为2个或者4个字节（16/32位），对于**常用字符集**，用两个字节表示；增补字符集用4个字节表示：前2个字节叫做高代理项，后2个字节叫做低代理项

——UTF-16定义了一个公式，可以将编号和4字节表示相互转换。

Java内部就是采用UTF-16编码。char就是一个字符（2个字节），但是只能表示BMP；而对于增补字符集，需要用2个char表示

int可以表示任意一个Unicode字符，用低21位表示，其余高11位设置为0。**整数编号在Unicode中称为代码点code point**——代表一个Unicode字符；**代码单元，表示一个char**

=>Unicode还给字符分配了一些属性

# 5. 大端 & 小端

- **大端字节序**：高位字节在前，低位字节在后——即高位字节先出现，低位字节后出现，符合人们日常读数：先读最高位后向下读

  eg: 0x123456, 12 存放在低字节处，56存放在最高字节处。

- **小端字节序**：低位字节在前，高位字节在后

  正好相反。

大端序方便人类查看，因为习惯从最高位开始看起；小端序方便机器处理，因为机器习惯从低位开始处理

——**只有读取的时候，才必须区分字节序，其他都是看成字节流**

大端序的读取：`x = buf[offset] << 8 + buf[offset+1];`

小端序的读取：`x = buf[offset+1] << 8 + buf[offset];`