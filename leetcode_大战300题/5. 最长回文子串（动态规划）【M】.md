# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210308180524737.png" alt="image-20210308180524737" style="zoom:67%;" />

## 1. 暴力解法

暴力解法的思路是：从起始开始，遍历每个>=2的字符串，看是否是回文串，再此基础上找最长的。

```java
class Solution {
    private boolean validParlindrome(char[] arr, int left, int right){	// 判断当前数组是否是回文串
        while(left <= right){
            if(arr[left] != arr[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    public String longestPalindrome(String s) {
        if(s.length() <= 1) return s;
        int begin = 0, maxLen = 1;
        char[] arr = s.toCharArray();			// 为了方便比较，直接转换成数组
        for(int i = 1; i < s.length(); i++){			// 固定本次循环的上界，即right
            for(int j = 0; j < i; j++){				// 固定本次循环的下界，即left
                // 稍微用了小技巧：先判断是否超过长度，再去调用方法（如果同样长度的回文串已经出现过了，就没有必要再判断一次）
                if(i - j + 1 > maxLen && validParlindrome(arr, j, i)){
                    begin = j;
                    maxLen = i - j + 1;
                }
            }
        }
        return s.substring(begin, begin + maxLen);		// 不用去存储当前最长串，只需要保存起始点和最长长度即可
    }
}
```

## 2. 动态规划

在暴力求解时，发现对每个回文串都会进行从头到尾的判断，这个是重复的操作，

eg：cdadcb，可以发现 我们对dad会判断一次，对cdadc也会判断一次，而前者是后者的子串，如果我们记录了dad这个子串是回文串的信息，那么我们在判断cdadc的时候，可以直接读表，然后只需要判断最外面的两个c即可

——**「回文」天然具有「状态转移」性质**，即一个回文去掉两头以后，剩下的部分依然是回文

所以，实际上根据上面的`validParlindrome`方法，我们已经可以写关于回文判断的状态方程式了：

**`dp[i, j] = (s[i] == s[j]) && dp[i+1, j-1]`**是，所以表格是一个二维数组。（i是行，定了left；j是列，定了right）

首先确定边界条件：——即上面的公式不满足，更具体地：i+1<=j-1，即`j - i>=2`，即字符串长度要大于等于3

- i = j，此时字符串长度为1，单个字符一定是回文串
- j = i + 1，说明字符串中只有2个元素，那么只需要判断i和j两个结点是否一样即可，即s[i] == s[j]?



参考：

1. https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/
2. https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/