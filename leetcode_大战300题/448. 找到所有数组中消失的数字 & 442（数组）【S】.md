# [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210307114521675.png" alt="image-20210307114521675" style="zoom: 80%;" />

## 1. 使用额外空间

可以想到用HashSet，遍历数组将所有的内容，放在set中，最后遍历[1,n]，看哪些数字没有出现

## 2. 原地修改

题目要求：不使用额外空间——不能用哈希表等存储；复杂度为O(N)，那么就是常量次遍历。

我的方法：一个萝卜一个坑（初始思路来自哪里找不到了）

想反例：如果正好是1~n个数字，有且仅出现一次，那么经过遍历之后一定能顺序排列，即1-1，2-2，...n-n（注意这边的index是从1开始的）

如果存在数字重复，那么一定有数组不存在的，数字重复那么在对应位置插入的时候会碰到碰撞：插入了相同的数字。

eg：3-3, 5-3，把index=5中的3插入到index=3，发现index=3已经存在匹配的3，所以3一定存在重复，

那具体步骤：

<img src="pic/448.jpeg">

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {   // 一个萝卜一个坑
        int len = nums.length;
        for(int i = 0; i < len; i++){
            while(nums[i] != i + 1){		// while循环，将值放入到对应的index中
                int temp = nums[i];
                if(nums[i] == nums[temp - 1]){      // 发生冲突
                    break;
                }
                nums[i] = nums[temp - 1];
                nums[temp - 1] = temp;
            }
        }
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < len; i++){
            if(nums[i] != i + 1) res.add(i + 1);
        }
        return res;
    }
}
```

[官方题解](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/)给的方法是：遍历数组，在遇到数x的时候，让nums[x - 1]的值增加n，那么增加之后，值一定超过n。所以对于未出现的数字，那么它对应的index里面的值一定在[1,n]范围内的：具体见[题解](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/)

参考：

1. https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/shou-hua-tu-jie-jiao-huan-shu-zi-zai-ci-kzicg/
2. https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/

# [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210307114544923.png" alt="image-20210307114544923" style="zoom: 80%;" />

本题就是上面一题的改编，稍微分析一下内核都是一样的

但是这个要求记录重复出现的数字，且由于重复只能出现2次，那么必须要避免重复碰撞——上面的解法会出现重复碰撞

所以，当出现碰撞的时候我们给其中一个设置为特殊的值0，当出现0的时候本次循环结束

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < nums.length; i++){
            while(nums[i] != i + 1){
                int temp = nums[i];
                if(temp == 0) break;		// 当前值为0，那么无法更别人交换
                if(nums[temp - 1] == temp){		// 发生碰撞，不交换，并且把当前结点的值设置为0，循环结束，看下一个结点
                    res.add(temp);
                    nums[i] = 0;
                    break;
                }
                else{			// 未发生碰撞，所以可以交换
                    nums[i] = nums[temp - 1];
                    nums[temp - 1] = temp;
                }
            }
        }
        return res;
    }
}
```

——这个方法是兼容前面一题的。