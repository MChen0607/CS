# 高频考点

## 	输入网址之后发生哪些事情？

举例：我们输入 www.baidu.com 之后发生了哪些事情？

## 1. HTTP

**第一步：解析URL**

首先，我们是在浏览器中输入网址的，那么**浏览器首先需要对URL进行解析**，然后生成发送给Web服务器的请求信息

先来看一下，输入的URL的各个元素代表的含义：

https://www.baidu.com/index.html

- `https:` 表示访问中遵循的协议

- `//`：表示后面的字符串是目标服务器

- `www.baidu.com`：是紧跟在//后面的，所以表示的是需要请求访问的Web服务器

- `/index.html`：**可缺省的**，表示该服务器上的数据源的路径名称，即该服务器中的文件路径，类似于`c:\users\admin\Desktop....`

  ——先找到web服务器，然后在该服务器的路径中找到对应的文件

  如果该部分是被省略的，eg：https://www.baidu.com，代表访问**根目录下的事先设置的默认文件**，，一般是/index.html 或者 /default.html

<img src="pic\image-20210130123156392.png" alt="image-20210130123156392" style="zoom: 50%;" />

**第二步：生成HTTP请求信息**

在第一步中对URL进行解析之后，确定了访问需要遵顼的协议、要访问的服务器的地址和文件路径，那么需要根据这两部分生成HTTP请求信息：

然后组合成了HTTP报文，发向网络

<img src="pic\image-20210130124747222.png" alt="image-20210130124747222" style="zoom: 50%;" />

## 2. DNS

**第三步：查询服务器对应的IP地址**

在发送HTTP报文之前，需要知道**该服务器域名所对应的IP地址**，$\because$ 委托操作系统发送消息，必须要提供通信对象的IP地址

用到之前的DNS技术

DNS服务器：专门保存了Web服务器域名和IP的对应关系

客户端会向本地DNS请求查询网址对应的IP地址（本地DNS服务器是客户端的TCP/IP中配置的，传递信息的方式就是IP数据报），而本地DNS会向根域DNS、顶级域DNS、权威DNS查询需要的网址对应的IP地址，直到找到之后返回给客户端

## 3. 协议栈

**第四步：HTTP的传输工作会交给操作系统中的协议栈完成**

已知了目的IP，那么交给协议栈工作了

协议栈内部分为几个部分，分别承担不同的工作。**部分之间是有上下级关系的**，上面的会向下面委托工作，下面接收委托工作并执行——类似于OSI模型的等级

<img src="pic\image-20210130150753412.png" alt="image-20210130150753412" style="zoom:67%;" />

1. 浏览器通过调用socket库，来委托协议栈工作

2. 协议栈上半部分是**TCP/UDP协议**，两者有功能上的区别，前者是一对一连接后才能收发数据，后者是不需连接多端收发，主要功能都是：**接收应用层的委托，执行收发数据的操作**，收发的是TCP/UDP数据报

3. 协议栈下半部分是**IP协议**，用来控制网络包的收发操作，收发的是IP数据报

   并且，IP中还包含了ICMP和ARP协议

   - ICMP：在出现传输故障的时候，负责通知故障原因和情况，以及各种控制信息
   - ARP：根据IP地址查询MAC地址

4. 协议栈下面是**网卡驱动程序**，主要是用来控制网卡硬件

5. 最下面是网卡，主要是负责完成实际的收发工作，对网线中的信号执行收发操作

## 4. TCP（协议栈里面的）

**第4.1步：HTTP数据报通过TCP层**

HTTP是基于TCP协议传输的

TCP的报文：（具体功能见TCP那份思维导图）

<img src="pic\image-20210130163240044.png" alt="image-20210130163240044" style="zoom:67%;" />

TCP是面向连接的、可靠的、基于字节流的传输层通信协议，能够保证可靠的有序的传输。并且，还能做到流量控制（窗口大小）、拥塞控制（自我控制传输的速度）

## 5. IP（协议栈里面的）

**第4.2步：TCP数据报包装IP首部，并且选择合适的网卡（即填入合适的源IP地址）**

主要是：主机和主机之间的传输了（TCP类似于应用到应用之间的传输），即点到点——点之间可能不直接相连的

IP层是TCP层的下一层，即网络层的操作。（具体见IP那份思维导图）

通过IP层的包装，那么能够知道从哪个IP地址出来，到哪个IP地址去

IP层的报文：

<img src="pic\image-20210130203732535.png" alt="image-20210130203732535" style="zoom:67%;" />

## 6. MAC

**第4.3步：根据IP地址获取MAC地址，并包装IP数据报**

IP数据报还需要在IP数据报外面再包一层**MAC头部**

该层主要的作用：IP层知道目的地是哪里，而MAC层就是一步步指示如何到目的地，即**下一步要去哪里**。

- IP层：没有直连的两个主机之间通信
- MAC层：直连的两个主机之间传输

MAC的包头格式：

<img src="pic\image-20210130215349066.png" alt="image-20210130215349066" style="zoom: 80%;" />

- 接收方的MAC地址 / 发送方的MAC地址：用于直连的两地传输

  - 发送方的MAC地址：**网卡在生产时已经写入ROM中**，那么只需要从网卡中读取出来写入到发送方的位置中即可

    ps：一个主机可能有多个网卡，已经在IP层确定了网卡，即IP地址，那么MAC地址也就相应确定了

  - 接收方的MAC地址：稍微复杂，但是一旦知道接收方的MAC地址，以太网会根据MAC地址将包发送过去

    - 首先：查询路由表，通过目的IP地址，查询最匹配的条目，然后将包发送给对应的IP地址即可——这边的IP就是和该主机直连的
    - 知道该IP地址后，还需要知道MAC地址，通过ARP协议查找，通过一个链路中的所有设备广播，然后符合的主机进行响应，返回的响应报文中塞入MAC地址
    - ps：OS会将该MAC地址放在**ARP缓存**中，但是缓存的时间在几分钟，所以实际上根据IP地址查询MAC地址
      - 1. 先去找ARP缓存中是否存在该条，存在就不需要ARP广播查询了，直接使用即可
        2. 当ARP缓存中不存在，那么需要ARP广播查询

- 协议类型：对于TCP/IP填写的是：**0800——IP协议/0806——ARP协议**

最后生成MAC报文：

<img src="pic\image-20210130221717779.png" alt="image-20210130221717779" style="zoom:67%;" />

## 7. 网卡

到前面步骤为止，报文的内容已经确定下来了，当前是一串二进制的数字信息，但是无法直接在网络上传输，需要将**数字信号转换为电信号**，才能在网线上传输

**将数字信号转换为电信号的操作是通过网卡**，而**控制网卡需要网卡驱动程序**。

**第5步：数字信号转电信号**

网卡驱动获得IP最后的数据包之后，将其复制到网卡的缓存区，然后再在开头加上**报头，和起始帧分界符**（用来标记包的起始为止，区分不同的帧），在末尾加上用于**检测错误的帧校验序列**（检查包传输过程中是否发生损坏）
最后在网络上传输的数据包就是如下结构的：

<img src="pic\image-20210130230137092.png" alt="image-20210130230137092" style="zoom:80%;" />

## 8. 交换机

交换机的概念：

- 功能：将网络包原样转发到目的地
- 工作位置：**MAC层**，所以又被称为**二层网络设备**

交换机的包接收操作：

- 1. 电信号到达了网线接口（在网线上传输的都是电信号），交换机里的模块进行接收，并且将电信号转换为数字信号

- 2. 网络包变成了数字模式，然后通过包末尾的FCS检查包是否发生损坏，如果没问题，那么就放在缓冲区

     ps：网卡和交换机存在区别：**网卡是存在MAC地址的**，所以在接收到包之后会先验证该包的目的MAC地址是否为自己，如果是就接收；如果不是，就直接丢弃；**交换机不存在MAC地址**，所以对所有经过它的网络包都统一接收并放入缓存

- 3. 包进入缓存后，会等待，当轮到它执行时，会先查询该包的接收方MAC地址是否已经在**MAC地址表**中
     <img src="pic\image-20210130232208249.png" alt="image-20210130232208249" style="zoom:67%;" />

     即可以查询该表格，将对应MAC地址的网络包，并将信号发送到对应的端口

     如果目的MAC地址在表格上不存在：

     - 原因：该MAC地址的设备还未向该交换机发送过网络包 / 该设备一段时间内未工作所以被从地址表中删除了
     - 操作：如果找不到，那就广播，将包发送给除源端口以外的所有端口，所有连接该交换机上的设备都能接收到该包——但是只有目标MAC地址的主机会接收，其他均忽略了
     - 影响：广播，不会造成网络拥塞。因为目标设备收到该包之后会做出响应，交换机收到该包之后就会在MACI地址表中增加该条，那么下次就需要广播了
     - ps：如果MAC地址是一个广播地址，那么需要将该包发送到除源端口以外的所有端口，广播地址有：MAC地址的**FF:FF:FF:FF:FF:FF**，对应IP地址的**255.255.255.255**

## 9. 路由器

网络包经过交换机后到达了路由器，然后通过路由器到达下一个路由器/目标地址

路由器与交换机的异同：

- 异：
  - 路由器是IP层的，又称三层网络设备。**路由器的各个端口都有MAC地址和IP地址**
  - 交换机是MAC层的，又称二层网络设备。交换机的端口没有MAC地址
- 同：工作原理类似：通过查表选择转发端口

路由器的工作原理：

一般都是转发包：在端口接收网络包；然后通过路由表查询转发的目标——下一跳，然后通过对应的端口转发出去

- 接收包：

  - 首先，电信号到达网线端口，路由器中对应的模块会接收该包，并且将电信号转换为数字信号，并且通过末尾的FCS进行错误校验

  - 接着，检查该包的MAC头部的接受方的MAC地址，如果接收方不是自己，那么直接丢弃；如果接收方是自己，那么放入缓存

  - 接收完成后，就会**丢弃该包的MAC头部**（因为需要通过该路由器转发出去，MAC头部需要变化了）

  - 缓存排队排到之后，根据IP头部的目的IP地址，**查询路由表**获得下一跳的IP地址——查询流程类似于网卡的选择过程：找到就选择作为下一跳目标，找不到就选择默认路由

  - eg：从10.10.1.101发送到192.168.1.100，那么到达该路由器之后，查询路由表，然后一条一条匹配，发现第二条匹配，那么该条记录就会作为转发目标；而如果都不匹配就选择最下面的默认路由

    <img src="pic\image-20210131134709820.png" alt="image-20210131134709820" style="zoom: 50%;" />

- 发送包：选择号转发目标之后，就要发送出去了

  - 先根据**路由表中的网关列**判断下一跳的地址
    - 如果网关显示的是IP地址，那么**该IP地址就要要转发的目的地**，表示**还未抵达终点**，需要继续转发
    - 如果网关为空，那么IP报文中的**接收方地址就是转发的目的地**，且已经**找到终点**了
  - 接着根据得到的转发IP地址，通过ARP协议得到MAC地址，并将结果写入到MAC头部的接收方MAC地址中
  - 然后，发送方的MAC地址，填写的是输出端口的MAC地址
  - MAC头部的协议字段填写的是0X80，表示IP协议——至此，MAC头部又重新添加完成了
  - 然后驱动网卡将数字信号转换为电信号，并通过端口发送到网线上

——然后，又通过交换机到达下一个路由器，然后重复操作，直到达到最终目的地

可以发现，在网络包传输的过程中，IP头部都是不变的，只是提供查询，而变化的是MAC头部，不断变化发送方的MAC地址和接收方的MAC地址——因为是在两个设备之间进行传输的，而IP地址是用来两个主机之间的传输的

## 10. 服务端（目的地）

<img src="pic\image-20210131143641016.png" alt="image-20210131143641016" style="zoom: 67%;" />

服务端开始将网络包打开查看

- 先看MAC头部，看接受方的MAC地址是否和自己的MAC地址一致，一致才接收，且把MAC头部丢弃
- 然后看IP头部，看接收方的IP地址是否和自己的IP地址一致，一致才接收，并且根据**协议位**，知道上层需要用到TCP协议
- 然后看TCP头部，里面有序列号，看序列号是否是期待的，如果是就放入缓存中，**然后返回一个ACK**，并且TCP中还包含接收方的端口号，而HTTP的服务器正在监听该端口
- 根据端口号将该包发送给HTTP进程，然后HTTP进程打开数据区了解到该包的目的，于是处理之后，重新一层层封装，发送回去

ps：交换机

路由器有交换机的功能，交换机就是用来交换数据的，eg：3台电脑连接在交换机上，那么这几台电脑能够互相交换数据了