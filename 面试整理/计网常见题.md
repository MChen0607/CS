# 计网常见题

来自[777](https://hishark777.gitbook.io/777-interview-notes/computer-network/interview-question#tcp-de-yong-sai-kong-zhi-man-kai-shi)

## 1. 路由器和交换机位于哪一层

路由器：网络层

[概念、作用、工作流程](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#2-%E4%BA%A4%E6%8D%A2%E6%9C%BA)

交换机：数据链路层

[概念、作用、工作流程](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#39-%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87%E8%B7%AF%E7%94%B1%E5%99%A8)

## 2. 计算机网络每层对应的协议

> 类似的：
>
> 1. 网络协议有了解吗

## 3. IP TCP 传输的都是什么数据

上层丢下来的TCP数据、UDP数据？

TCP传输的是上层丢下来的HTTP、FTP、SMTP的字节流

## 4. IP 头都有啥内容

看IP首部的内容：https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#32-ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F

## 5. TCP连接的三次握手，四次挥手

> 引申的：
>
> 1. why需要3次握手，2次可以吗？
> 2. why挥手要4次，3次可以吗？
> 3. 每个报文丢失会如何进行补救？

[具体见](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#45-tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%87%8A%E6%94%BE)

## 6. TCP 与 UDP 协议的区别

> TCP的特点？
>
> TCP的概念？

6点：[具体见](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#1-%E6%A6%82%E5%BF%B5-3)

## 7. 浏览器渲染页面完成后会保持 TCP 连接吗

根据请求头中的 Connection 判断，若为`keep-alive`则保持连接。

## 8. TCP 连接和释放中的状态有哪些，以及如果日志中出现某些状态码过多如何处理

就是TCP3次握手和4次挥手的那些个状态。

状态码过多会出现在：

1. 握手：syn-recv过多——syn攻击

2. 挥手：

   close-wait——服务器在传送数据完成之后忘记发送ack了，检查代码

   time-wait——2msl设置过长，修改参数

## 9. TCP 的拥塞控制、慢开始

[概念、操作](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#49-tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)

## 10. TCP为什么是可靠的。注意拥塞机制涉及的算法（慢开始，拥塞避免，快重传，快恢复）

TCP的可靠保证：[具体见](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BF%9D%E8%AF%81.md#tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BF%9D%E8%AF%81)

1. 重传机制：超时重传、快速重传、SACK、D-SACK
2. 滑动窗口
3. 流量控制
4. 拥塞控制

## 11. 为什么需要快重传和快恢复，什么场景下使用

快重传可以和超时重传一起存在，快重传是接收方收到乱序编号之后，会立即返回ack，发送方收到3个连续的重复的ack之后会触发。

——由于发送方能尽早重传未被确认的报文段，因此采用快重传后可以使整个网络的吞吐量提高约20%。

此时网络拥塞程度并不大，为了预防网络发生拥塞，然后将ssthresh=cwnd/2=cwnd，然后开始执行拥塞避免算法

[快恢复](https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BF%9D%E8%AF%81.md#44-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D)

## 12. TCP服务端能否无限等待

不能，有一个保活机制

## 13. 滑动窗口的实现机制以及如何作用流量控制

滑动窗口：本质上是os分配的一块缓存区。分为发送窗口、接收窗口。

在发送窗口内的数据无需等待前面的ack，直接能进行发送。

发送窗口大小，即无需等待确认应答，还是可以继续发送的数据的最大值。

那么接收方可以在某个时刻发送ack，ack的内容就是当前收到的最后一个有序的编号——累计确认、延迟确认

接收方在ACK中会在首部的窗口大小字段通知发送方窗口大小——给发送方的窗口大小作为一个依据。

如果接收方数据处理比较慢，那么接收窗口比较小，也会反馈给发送方变小窗口。

流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。接收方在ACK中会在首部的窗口大小字段通知发送方窗口大小。

——零窗口大小，存在持续计数器，避免死锁。

## 14. UDP 主要有哪些应用

UDP 常用于以下几个方面：

1. 包总量较少的通信（DNS、SNMP等）；
2. 视频、音频等多媒体通信（即时通信）；
3. 限定于 LAN 等特定网络中的应用通信；
4. 广播通信（广播、多播）。

eg：DNS、DHCP、RIP

## 15. UDP如何实现可靠传输

最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。

HTTP3：QUIC：就是用UDP实现的。

## 16. DNS 域名解析的过程

> 类似问题：
>
> - DNS解析过程，如果服务器ip地址改变了，客户端怎么知道呢？——TTL值，设置小一点，就会要更新IP值
> - DNS域名解析过程，接收到DNS查询结果之后还做了什么？——告诉主机，并且主机设置缓存

## 17. DNS缓存存在哪？有效期多少？可以设置吗？

缓存：浏览器、os的cache里面、缓存到磁盘中主机的host文件中，本地DNS等也会存在缓存

DNS记录会有一个ttl值(time to live)，单位是秒，意思是这个记录最大有效期是多少

ttl值是DNS服务器返回时给定的值

浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关：每种浏览器都有一个固定的DNS缓存时间，其中Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS；

OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值

https://www.cnblogs.com/itfat/p/10622570.html

## 18. 分析一个 URL 各字段的含义

**协议:** 

- HTTP协议或者安全协议 HTTPS
- mailto:用户打开邮箱的客户端
- ftp:用来做文件的转换, file用来获取文件,data获取外部资源等

**域名或IP:** 标明了需要请求的服务器的地址.

**端口:** 标明了获取服务器资源的入口——**区分服务的端口**，80端口是默认隐藏的

**文件路径:** 表示服务器上资源的路径,过去这样的路径标记的是服务器上文件的物理路径,但是现在,路径表示的只是一个抽象地址,并不指代任何物理地址.

**参数(查询字符串):** 是请求里提供的额外参数.这些参数是以键值对的形式,通过**&符号**分隔开来,服务器可以通过这些参数进行相应的个性化处理

请求参数和对应的值附加在URL后面，利用一个**问号（“?”）**代表URL的结尾与请求参数的开始

——存在的问题：显式提供参数，不适合私密传输。并且如果参数过多，超过浏览器可处理的URL长度，那么不能使用get方法了。

## 19. GET 请求和 POST 请求的区别

https://www.oschina.net/news/77354/http-get-post-different

get是幂等的、安全的。post不是

- GET在浏览器回退时是无害的，而POST会再次提交请求。

缓存的角度：

- GET产生的URL地址可以被Bookmark，而POST不可以。
- **GET请求会被浏览器主动cache**，而POST不会，除非手动设置。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

编码方式：

- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

安全性：

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

参数：

- GET参数通过URL传递，POST放在Request body中。

GET和POST还有一个重大区别，简单的说：

**GET产生一个TCP数据包；POST产生两个TCP数据包。**

- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
- 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

——据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

——但是，不同的浏览器操作是不同的，firefox就只发送一次。

## 20. HTTP 的八种方法，有没有用过

> 类似问题：
>
> - 知道其他请求方式吗，比如Put，Delete，Head
> - GET POST请求，除了这两个还有啥

有8种方法：

1. GET：最常见的

   客户端需要从服务端获得数据，获得文件、网页资源等。

   服务端在进行响应的时候，会将响应内容放在实体行中。

   get会将请求的参数、数据等显式的放在url中，用?区分URL和参数列表；多个参数之间用&分隔。

   ——存在的问题：显式提供参数，如果是私密的参数就会被窃听；如果参数过多，有些浏览器（1024个字符）就自动忽略后面的参数

2. POST：允许客户端给服务器提供信息较多

   将参数封装在实体行中，各数据之间也是使用”&”符号隔开

   POST方式大多用于页面的表单中

   POST可以根据请求来处理资源，不是幂等的

3. HEAD：类似于get

   区别：只有响应头，没有响应内容。只想要看页面的状态反馈时，用head高效，因为没有内容传输快。

4. PUT：向指定资源位置上传其最新内容

   PUT是会覆盖整个目标资源，**是幂等的**，

5. DELETE：请求服务器删除指定的页面

   返回值：200正确删除，且返回删除内容；202接收删除请求，但是没有立即删除，而是移动到了待删除区域；204删除已经执行，但是没有返回内容

6. OPTIONS：获取服务器支持的请求类型或者查看服务器类型

7. TRACE：回显服务器收到的请求，主要用于测试或诊断

8. CONNECT：HTTP/1.1 协议中预留给能够将连接改为**管道方式**的代理服务器

## 22. HTTP报文首部的User-Agent字段

用户代理

User-Agent会告诉网站服务器，**访问者是通过什么工具来请求的**，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。——爬虫用到过

F12->Network->F5刷新->文件->headers->user_agent=`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36`

多个公司的**浏览器标识**，如：Mozilla、Chrome、Safari；包含多个**渲染引擎标识**，如：AppleWebKit、KHTML、Gecko。

- AppleWebKit/537.36：苹果公司开发的呈现引擎
- KHTML：是Linux平台中Konqueror浏览器的呈现引擎KHTML
- like Gecko：表示其行为与Gecko浏览器引擎类似

可以看到包含了谷歌浏览器，因为AppleWebKit渲染引擎是苹果公司开发的，而Google公司要采用它，为了获得服务器端的正确响应，仅在Safari浏览器UA字段中增加了Chrome字段。

可以看到用户代理中包含多个浏览器标识：多增加一些字段都是为了让服务器检测到它支持的浏览器标识，以便获得服务器的响应，从而提升用户体验

IE浏览器：`   User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko`

## 23. HTTP的报文格式

> 类似问题：
>
> 1. HTTP头

https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#2-http%E5%8D%8F%E8%AE%AE

报文分为：请求报文、响应报文。

开始行：请求报文中是请求行；响应报文中是状态行；

​				请求行：包含方法、URL、http版本；——URL：可以是相对路径（路径放在首部行的host中）、绝对路径

​				状态行：http版本、状态码、对状态码的简单解释

首部行：关键字/值对组成，关键字和值用英文冒号“:”分隔

​				常见的：

> > > > 通用的：
> > > >
> > > > 1. Connection: keey-alive
> > > > 2. Cache-Control：控制缓存的行为
> > > > 3. Date
> > > >
> > > > 请求的
> > > >
> > > > 1. Host: xxx
> > > >
> > > > 2. Accept：客户端可以处理的类型
> > > >
> > > > 3. Accept-Charset：客户端可以处理的字符编码方式
> > > >
> > > > 4. Accept-Language：客户端接收的
> > > >
> > > > 5. Cookie：在有关联性的网页中，带上cookies，可以避免进行身份验证
> > > >
> > > > 6. User-Agent：用户代理
> > > >
> > > > 7. Etag：看内容是否发生变化，如果没有变化那么不需要传输内容
> > > >
> > > >    再次向web服务器发送请求并带上头If-None-Match（Etag的值），web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304(浏览器会从缓存中获取)。
> > > >
> > > > 响应的：
> > > >
> > > > 1. Content-Length：响应字段的长度
> > > > 2. Content-Type：内容的类型，eg：Content-Type: text/html; charset=UTF-8
> > > > 3. Content-Encoding：压缩的类型，eg：Content-Encoding: gzip
> > > >
> > > > 

空行（CR+LF）：表示下面是实体内容

实体行：POST方法中使用；响应中的具体内容存放在这边

## 24. HTTP 3xx系列的状态码

> 类似：
>
> 1. 2xx、4xx、5xx等的状态码

## 25. HTTP 如何实现断点续传的

https://blog.csdn.net/zhangliangzi/article/details/51348755

HTTP状态码应该是206。

客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。

多线程断点续传实现的基本思想：

- 在发送端（也称客户端）将要传输的文件分割为大小相当的多块，用多个线程，将这些块同时向目标服务器端发送；
- 在服务器端的服务程序监听数据传输请求，每当接到新的请求，则创建一个新的线程，与客户端的发送线程对应，接收数据，记录数据传输进程

## 26. HTTP 缓存

https://www.jianshu.com/p/227cee9c8d15

1. 如果请求相同的资源，则可以直接返回http缓存，避免http请求——http缓存都是从第二次请求开始的
2. 常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力

http缓存分为：强制缓存，协商缓存

- 强制缓存如果生效，不需要再和服务器发生交互

  强制缓存在缓存数据未失效的情况下，直接使用浏览器的缓存数据，不会再向服务器发送任何请求。那么如果服务器内容有更新，客户端是无法及时获取的。

  页面的加载速度是最快的，性能也是很好的。

- 协商缓存不管是否生效，都需要与服务端发生交互

  第二次请求，服务器端会对比判断资源是否进行了修改更新，没有修改，那么就会返回304状态码。

  数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

## 27. HTTPS SSL 加密

> 类似：
>
> 1. SSL 的运行原理，如何确保安全传输
> 2. 对称加密和非对称加密
> 3. HTTPS是如何加密的，详细说下加密算法
> 4. HTTPS 的加解密过程
> 5. 加密过程，对称加密怎么保证安全

SSL/TLS的4次握手过程

https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/HTTP.pdf

## 28. 知道哪些加密算法

对称加密、非对称加密

常见的 **对称加密** 算法主要有 `DES`、`3DES`、`AES` 等，常见的 **非对称算法** 主要有 `RSA`、`DSA` 等，**散列算法** 主要有 `SHA-1`、`MD5` 等

https://juejin.cn/post/6844903638117122056

`MD5` 用的是 **哈希函数**，它的典型应用是对一段信息产生 **信息摘要**，以 **防止被篡改**。严格来说，`MD5` 不是一种 **加密算法** 而是 **摘要算法**。无论是多长的输入，`MD5` 都会输出长度为 `128bits` 的一个串

`SHA-1`类似于`MD5`

`RSA` **加密算法** 基于一个十分简单的数论事实：将两个大 **素数** 相乘十分容易，但想要对其乘积进行 **因式分解** 却极其困难，因此可以将 **乘积** 公开作为 **加密密钥**。

<img src="../计网/非对称加密基本原理.jpg" style="zoom: 20%;" >

`DES` 加密算法是一种 **分组密码**，以 `64` 位为 **分组对数据** 加密，它的 **密钥长度** 是 `56` 位，**加密解密** 用 **同一算法**。

## 29. CA证书怎么生成，怎么保证安全

https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/HTTP.pdf

## 30. HTTP 和 HTTPS 区别

> 类似问题：
>
> - HTTP和HTTPS原理，区别，各自的优势
> - HTTP2和HTTPS关系
> - HTTP1.0和HTTP2.0的区别

区别：

1. 端口：http：80；https：443
2. http下层是tcp；https还有一个ssl/tls层
3. http是明文传输；https是加密传输
4. http响应速度快，https速度慢，但是安全性好

## 31. 抓包工具用过吗，为什么抓包可以抓取HTTPS的所有数据

> 类似问题：
>
> 1. 抓包的原理

https://bbs.huaweicloud.com/blogs/178367

HTTPS抓包过程：

1. 客户端**连接**抓包工具提供的代理服务；
2. 客户端需要安装抓包工具的**根证书**；
3. 客户端发出 `HTTPS` 请求，抓包工具模拟服务器与客户端进行 `TLS` **握手交换密钥**等流程；——客户端与抓包服务器进行TLS连接
4. 抓包工具发送一个 `HTTPS` 请求给客户端请求的目标服务器，并与目标服务器进行 `TLS` **握手交换密钥**等流程；——抓包服务器和服务端进行TLS连接
5. 客户端使用与抓包工具协定好的**密钥加密**数据后发送给抓包工具；——抓包服务器已经获得了对称密钥，然后可以获取客户端的原始数据
6. 抓包工具使用与客户端协定好的**密钥解密**数据，并将结果进行展示；
7. 抓包工具将解密后的客户端数据，使用与服务器协定好的密钥进行加密后**发送给目标服务器**；
8. 服务器解密数据后，做对应的逻辑处理，然后将返回结果使用与抓包工具协定好的密钥进行加密**发送给抓包工具**；
9. 抓包工具将服务器返回的结果，用与服务器协定好的**密钥解密**，并将结果进行展示；
10. 抓包工具将解密后的服务器返回数据，使用与客户端协定好的密钥进行**加密后发送给客户端**；
11. 客户端解密数据；给抓包工具，抓包工具将返回结果进行展示；
12. 抓包工具将服务器返回的结果原样返回给客户端；

——所以，抓包工具是中间人身份。

## 33. 在浏览器中输入网址回车后发生了什么？

> 类似问题：
>
> - 访问一个页面发生了什么
> - 网页中输入一个网址会发生啥
> - 浏览器输入网址之后的具体操作
> - 在浏览器中输入一个网站点击回车会发生什么
> - 你在访问一个网站的时候，发生了什么，涉及到什么协议，讲传输层里的。
> - 用户通过浏览器访问你的博客网站，用到了哪些协议？
> - HTTP 报文发送的全过程

https://github.com/amyZhoucc/CS/blob/main/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E2%80%94%E2%80%94%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85.md

## 34. 即时视频用什么协议

RTP协议：为实时应用提供端到端的运输，但不提供任何服务质量的保证

流程：需要发送的多媒体数据块（音频/视频）经过**压缩编码**处理后，先送给RTP封装成为RTP分组，RTP分组再装入运输层的UDP用户数据报，然后再向下递交给IP层

RTP分组只包含RTP数据，而控制是由另一个配套使用的RTCP协议提供的。

——只是用来传输数据的，而RTCP是用来控制的。

RTCP的功能：服务质量的监视与反馈、媒体间的同步，多播组中成员的标志。RTCP分组使用UDP来传送，但RTCP并不对音频/视频分组进行封装

RTCP分组周期性地在网上传送，它带有发送端和接收端对服务质量的统计信息报告。

## 35. 网络较差用什么协议

UDP，eg：视频通话

不需要很准确、但是需要实时性好的情况下，适合UDP。TCP需要握手连接，且保证可靠性，所以如果在网络差的情况下，丢包问题严重，而又不断发生超时重传（快速重传），但是网络状态更差了。

## Socket 创建流程

## 谈谈对 Token 的理解

Token是服务端生成的，给客户端的身份证，客户端每次在请求同一个服务器的时候，带上token，从而实现状态保留。

why要token：

1. 不允许cookie
2. Session认证就会暴露问题。因为每个用户在认证后，服务器都会记录Session，一般保存在内存中，随着认证用户增多，服务器开销也会增大；在多集群分布式的场合，会造成验证失败的情况。对负载均衡、应用的扩展都会造成影响。
3. **Token认证机制不需要保存认证用户的信息、也不需要考录用户在那台服务器登录，可以很好地适应应用的扩展（可以多服务共享）**

token认证能解决以下问题：

- Token 完全由应用管理，所以它可以避开同源策略

- Token 可以避免 CSRF 攻击

  CSRF攻击：黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，所以对于token是无效的

- Token 可以是无状态的，可以在多个服务间共享（跨域访问）

Token 需要设有效期：尽可能的短。

## cookie 和 session 有了解吗

https://www.cnblogs.com/ityouknow/p/10856177.html

cookie：服务器发送到用户浏览器并保存在本地的一小块数据，浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。

——主要是因为https是无状态的，所以需要用cookies

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失。当客户端关闭会话，或者 Session 超时失效时会话结束。

Cookie 和 Session 有什么不同？（5点）

- 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
- 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的**默认登录功能**，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。

why需要cookies和session，他们之间的关联？

cookie主要是因为http是无状态协议，在面对需要状态管理的时候需要有标志来控制身份。

流程：

- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID **返回给浏览器**，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 **Cookie 记录此 SessionID 属于哪个域名**。
- 用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

——SessionID 是连接 Cookie 和 Session 的一道桥梁

如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转？

1. 每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 `xxx?SessionID=123456...`（安全性不高）

2. Token 机制：服务端生成的一串字符串，作为客户端进行请求的一个标识——和cookie、session类似

   ——客户端只需带上这个 Token 前来请求数据即可

如何考虑分布式 Session 问题？

后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

——**共享 Session**，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致

## 跨域问题如何解决

[什么是跨域？](https://juejin.cn/post/6844904100035821575#heading-67)

什么是同源：`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`

不同源：不能读取or修改对方的DOM；不能读取对方的cookie、localstorage、indexDB

当浏览器向目标 URI 发 Ajax 请求时，只要**当前 URL 和目标 URL 不同源**，则产生跨域，被称为`跨域请求`。——一般会被浏览器所拦截，能到客户端，但是到不了浏览器。主进程检查到跨域，且没有cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程

解决跨域请求的常用方法是：

https://segmentfault.com/a/1190000022398875

- 通过代理来避免，比如使用 Nginx 反向代理

  反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的**负载均衡**，换句话说，反向代理帮**其它的服务器**拿到请求，然后选择一个合适的服务器，将请求转交给它。

- 通过 Jsonp 跨域

- CORS：使用**额外的HTTP头来告诉浏览器，允许跨域访问**

  1. 对于简单请求：添加一个`Origin`字段，用来说明请求来自哪个`源`，服务器拿到请求之后，在回应时对应地添加**`Access-Control-Allow-Origin`**字段，如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截。

     与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。

     **Access-Control-Allow-Credentials**。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为`true`, 并且在前端也需要设置`withCredentials`属性

  2. 对于非简单请求：**预检请求**和**响应字段**

     首先会发送**预检请求**，方法是`OPTIONS`，同时会加上`Origin`源地址和`Host`目标地址

     同时也会加上两个关键的字段:

     - Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法
     - Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头

     **响应字段**，响应字段也分为两部分，一部分是对于**预检请求**的响应，一部分是对于 **CORS 请求**的响应，

     现在它和**简单请求**的情况是一样的

  

ps：简单请求 & 非简单请求

1. 简单请求

   - 请求方法为 GET、POST 或者 HEAD
   - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type

2. 非简单请求

   不满足上面的，均是非简单请求

## 什么是子网掩码，它的作用是什么

获得IP地址对应的网络地址。

在路由器进行路由选择中用到：

根据数据中的目的IP地址，与子网掩码进行与操作，看是否和目的网络地址相匹配，如果匹配的话，就选择该条目的网关转发出去。

如果当路由表中存在多个路由项可以同时匹配目的IP地址时，路由查找进程会选择其中掩码最长的路由项进行转发，掩码越长表明其代表的网络范围越小，匹配的程度就越精确。这就是所谓的最长匹配原则。



http进阶的：（未看完）

https://juejin.cn/post/6844904100035821575#heading-23