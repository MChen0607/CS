# OS常见题

## 1. 进程和线程

> 1. 谈谈对操作系统中的**进程**的理解

概念：进程是资源分配的基本单位；线程是调度的基本单位。

区别：

- 进程的**系统开销大**；线程开销少；eg：进程的上下文切换，进程的创建和回收。
- 进程间通信：需要通过IPC来实现；同一个进程下的线程直接共享内存区即可通信

why：有进程还需要线程？

https://blog.csdn.net/N1314N/article/details/93711245

> 类似问题：
>
> 1. 一定有线程吗？为什么要有线程？
> 2. 为什么有多进程也有多线程？

线程产生的原因：

1. 进程如果发生上下文切换，开销很大；
2. 进程间通信需要用到IPC方法，麻烦

所以，引入粒度更小的线程：线程的优势同上，且还有如下优势：

1. 对于线程数<cpu数，那么线程可以运行在不同的cpu上；——更合理的利用多CPU系统
2. 改善程序结构，长且复杂的程序可以考虑分为多个线程，然后多个之间可以独立运行，提高效率且方便修改

## 2. 进程间通信

> 类似问题：
>
> - 操作系统中有哪些跨进程通信（IPC）的方法
> - 前面你说到了进程通信，那么有哪几种进程间通信的方法呢
> - 线程和进程的同步机制和通信机制

6种：**管道、FIFO命名管道、消息队列、信号量、共享存储、套接字。**

1. 管道（未命名管道）

   https://github.com/amyZhoucc/CS/blob/main/os/%E8%BF%9B%E7%A8%8B%20%26%20%E7%BA%BF%E7%A8%8B.md#143-%E7%AE%A1%E9%81%93

2. FIFO命名管道

   取消只有父子进程才能通过管道进行通信的限制。实现了任意两个进程均能实现通信。

3. 消息队列

   消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

   消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

   相比于 FIFO，消息队列具有以下优点：

   - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难。
   - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法。
   - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

4. 信号量：其实是共享数据对象的安全访问机制

5. 共享存储：允许多个进程共享一个给定的存储区。能够很容易控制容量，速度快，但要保持同步——共享内存是最快的 IPC 方式，但是需要保证进程间同步

6. 套接字：IP地址+端口地址，可以实现主机之间在网络上的传输

ps：

> 进程间通信和进程间同步有啥区别呢？

- 进程同步：

  控制不同进程的执行顺序，让**进程按照一定的顺序执行**。互斥又是特殊的同步

  进程之间需要配合做一些事情。

- 进程间通信

  进程之间传输信息

**进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。**

ps：

> 1. 为啥要进行进程间通信呢？
> 2. 进程间通信的概念

https://github.com/amyZhoucc/CS/blob/main/os/%E8%BF%9B%E7%A8%8B%20%26%20%E7%BA%BF%E7%A8%8B.md#14-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1

## 3. 进程同步

> 类似问题：
>
> 1. 为啥需要进程同步

需要让不同的进程按照一定的顺序执行，从而协调进程之间的协作任务。

> 类似问题：
>
> 1. 同步和互斥的区别

同步：进程之间的合作关系，直接制约关系

互斥：进程之间的制约关系，间接制约关系

## 4. 线程通信

方式一：使用 volatile 关键字。使用共享内存的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式。

方式二：使用 Object 类的wait()、notify() 和 notifyaAlL()，它们是多线程通信的基础，而这种实现方式的思想自然是线程间通信。

注意：wait() 和 notify() 必须配合 synchronized 使用。

> 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。只能用在同步方法或者同步控制块中使用，否则会在运行时抛出IllegalMonitorStateException。使用 wait() 挂起期间，**线程会释放锁**。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

## 5. 读者写者模型

> 类似问题：
>
> - 读者-写者问题
> - 生产者-消费者模型，其中的同步机制是怎么样的

## 6. 进程与线程的切换开销



## 7. 死锁以及如何避免死锁

> 类似问题：
>
> - 死锁的四个条件，开发过程中什么情况容易造成死锁

死锁的4个条件：

https://github.com/amyZhoucc/CS/blob/main/os/%E5%90%8C%E6%AD%A5%20%26%20%E6%AD%BB%E9%94%81.md#21-%E6%AD%BB%E9%94%81%E7%9A%84%E7%89%B9%E5%BE%81x

死锁的处理方法：

https://github.com/amyZhoucc/CS/blob/main/os/%E5%90%8C%E6%AD%A5%20%26%20%E6%AD%BB%E9%94%81.md#22-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95

## 8. 什么是抢占

优先级调度中....

## 9. 并发和并行分别是什么意思，多线程是并发还是并行

> 类似问题： 
>
> 单CPU能实现多任务并行吗

 多线程与并发、并行没有关系，只有多CPU才能实现并行，单CPU只有并发。

## 10. CPU 调度算法

> 类似问题：
>
> - CPU 调度算法，多核的情况下，操作系统怎么处理

普通的调度算法：6个

实时操作系统调度算法：3个

多核的操作系统调度算法：非对称多处理器（主CPU决定所有调度，其他CPU就是一个简单的计算器）、对称多处理器（每个处理器自行决定调度）

Linux有一个完全公平调度程序。

> 调度的概念

https://github.com/amyZhoucc/CS/blob/main/os/%E8%BF%9B%E7%A8%8B%20%26%20%E7%BA%BF%E7%A8%8B.md#31-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5

> 调度的时机

4个

## 11. 线程安全

**原子性（Atomicity）**：单个或多个操作是要么全部执行，要么都不执行

- Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
- synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问

原子性就是说一个操作不可以被中途cpu暂停然后调度**，**即不能被中断，要不就执行完，要不就不执行。如果一个操作是原子性的，那么在多线程环境下，就不会出现变量被修改等奇怪的问题。

**可见性（Visibility）**：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改

- volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
- synchronized：在释放锁之前会将工作内存新值更新到主存中

**有序性（Ordering）**：程序代码按照指令顺序执行

- volatile： 本身就包含了禁止指令重排序的语义
- synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入

## 12. 什么是互斥锁/读写锁

Java里面的

## 13. 知道哪些锁，说说它们的区别

Java里面的

锁的分类：无锁、自旋锁、偏向锁、轻量级锁、重量级锁

## 14. 什么是写优先和读写平衡



## 15. 多线程访问堆段会出现什么问题，如何解决这些问题

> (信号量、锁)

## 16. 时间片

> 4个CPU，16个数，每个CPU每次只能比较一次两个数的大小，只能返回`true`或`false`，互相之间不能通信，一轮以时间片为单位，需要几轮能够找出最大的数（4个CPU与4个数，可以一轮就找到最大的数吗）



## 17. 计算机寻址的方式

## 18. 直接寻址和间接寻址谁更安全

## 19. 指针能不能访问0x0

## 20. 如何在进程中直接操作物理地址

## 21. 地址空间的概念

## 22. 操作系统有哪些算法支持高效的内存的申请与释放，同时最大化的减少碎片

zero-copy 与 copy-on-write(COW);

## 23. 页一般多大



## 24. 分页分段管理

> 类似：
>
> 1. 分段和分页有什么区别
> 2. 操作系统的内存管理

## 25. 说说共享内存的原理

## 26. 虚拟内存的作用

## 27. 什么是虚拟内存、共享内存、物理内存

> 类似问题：
>
> 1. 虚拟内存和物理内存的区别

## 28. 假如手机只有10M内存，想要申请1M的内存是否一定成功

不一定。

看内存布局，如果留给堆内存的量已经小于<1M了，那么一定申请失败。

## 29. 内存分布

## 30. 进程的内存布局，哪些是线程共享

>  类似问题：
>
> 1. 堆和栈的区别



## 31. 文件I/O的过程



## 32. 中断

> 类似问题：
>
> - 中断是什么，Linux的中断命令
> - 中断是怎么实现的
> - linux 崩溃中断
> - 解释一下中断

## 33. 什么情况下会stackoverflow



## 34. 程序崩溃



## 35. 为什么要分用户态、内核态

> 类似问题：
>
> - 用户态/内核态
> - 内核态、用户态相关，扯了几句异常控制流



## 36. 大小端

大端：内存的低位地址存储数据的高字节，0x1234   -- 低地址：0x12；高地址：0x34——方便人的数据读取

小端：内存的低位地址存储数据的低字节——方便计算机处理