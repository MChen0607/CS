# 【Java基本功】锁概念汇总

### 公平锁/非公平锁

公平锁，是指按照线程申请的顺序获取锁。——类似于OS中的显式锁机制（需要一个等待队列去存放等待的线程，而等待是按照FIFO）

非公平锁，是指不是按照线程申请的顺序获取锁，有可能后申请的线程反而先获取到锁。比如该线程在申请的时候，锁刚好可用，那么不阻塞就能获取到锁，而不用去唤醒所有线程。能够减少唤醒线程的开销

——假如先来的线程一直获取不到锁，会造成锁饥饿现象。

ReentrantLock中可以通过构造方法指定是否为公平锁，默认为非公平锁，非公平锁的优点在于吞吐量大。

synchronized无法指定为公平锁，一直都是非公平锁。

### 可重入锁（递归锁）

同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），可重入锁的优点是能够一定程度避免死锁。并且会记录进入的次数，只有将锁全部释放掉，即count==0，才会彻底释放该锁

对于存在递归调用的方法如果使用不可重入锁，那么容易造成死锁

ReentrantLock和synchronized都是可重入锁

NonReentrantLock是不可重入锁

ReentrantLock和NonReentrantLock都继承自父类的AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

- 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。
- 非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。
- 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁
- 非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

### 独享锁/共享锁

独享锁，是指锁一次只能被一个线程持有。

共享锁，是指锁一次可以被多个线程持有。

ReentrantLock和synchronized都是独享锁，ReadWriteLock有两把锁：读锁是共享锁，写锁是独享锁（可重入的）——如果写锁在获取锁时，如果存在其他线程在写or其他线程在读，那么都不能获得锁，必须要等到全部的读结束/全部的写结束（可重入的原因），才能获取锁；而如果时当前线程获得写锁，而等待读锁	

读锁和写锁的实现原理：

还是AQS的state字段（int类型，32位），它用来描述有多少线程持有锁

在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。

ps：分析一下`ReentrantReadWriteLock`的简单实现：

读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。

获取写锁：

```java
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();		// 获取当前线程
    int c = getState();			// 获取锁的状态——即持有锁的数量
    int w = exclusiveCount(c);		// 获取state的低16位的值——对应写锁的数目（>1，都代表重入数目）
    if (c != 0) {			// 代表已经有线程持有锁（可能是读/写/读+写）
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())	// 如果没有写锁——那么只有读锁,or有写锁，但是写锁不是当前线程占用——就返回失败
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT)			// 如果重入次数已经超过上限，2^16-1，即65535，那么发生越界，抛出异常
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        setState(c + acquires);		// 到这一步，说明c>0,w>0,那么就是重入的，那么就计算重入的次数
        return true;
    }			// 到这边，说明c=0，该锁没有被占用
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))			// 当前线程需要被阻塞，或者如果通过CAS增加写的次数失败，那么就返回失败
        return false;
    setExclusiveOwnerThread(current);			// 通过CAS已经占用了写锁，那么再去设置该读写锁的拥有者，并且返回成功
    return true;
}
```

获取读锁：

```java
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();		// 获取state的状态——即持有锁的数量
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)	// 如果存在写锁，且写锁不是当前线程占用，那么返回失败——如果是当前线程拥有写锁，那么可以获取读锁
        return -1;
    int r = sharedCount(c);			// 计算读锁的占用的数目
    if (!readerShouldBlock() &&
        r < MAX_COUNT &&
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```

可以发现：

写锁占用的时候：其他线程不能读/写，而线程自己可以读/写（重入）——而自身的读，能够保证写入的可见性，因为一定是串行执行的

读锁占用的时候：其他线程能读，不能写，而线程自己可以读，不可以写——如果允许了读锁，那么再获取写锁，那么其他线程在读的时候无法感知到最新的写入。——所以写锁，只能在读全部释放后才能



### 互斥锁/读写锁

ReentrantLock和synchronized都是互斥锁

ReadWriteLock是读写锁

### 乐观锁/悲观锁

悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会发生修改也这么认为，所以一定要加锁。即，写比读多

——synchronized和lock都是悲观锁

乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试or其他操作。即，读比写多。

——原子类就是乐观锁实现的，底层是[CAS实现](http://note.youdao.com/noteshare?id=9f8ab6eaf048c06b8c823ebe1c7f0b8c&sub=38FCCF96A0C74660A8B19E1140BA449E)

**适用场景**：

- 悲观锁适合于写操作多的场景，能保证正确性
- 乐观锁适合于读操作多的场景，能提高并发性能

### 自旋锁/适应性自旋锁

背景：主要是针对普通的锁，如果发生需要阻塞线程，那么会对应产生线程阻塞和唤醒，需要切换上下文。如果同步代码块较为简单，那么上下文切换的相对代价会大很多。

而自旋锁，是指尝试获取锁的线程不会阻塞，而是**循环**的方式不断尝试，不放弃自己所拥有的CPU时间，等待持有锁的线程去释放锁，如果获得了锁，那么不需要阻塞和唤醒，可以直接获得锁。在多处理器的情况下很合适，多个线程**并行执行**，那么自旋锁很有可能能等到资源

- 优点是减少线程的上下文切换带来的开锁，提高性能
- 缺点是循环会消耗CPU，因为一直占用当前的时间片时间，如果锁被其他线程占用的时间很长，那么cpu资源就被浪费了

针对占用CPU的问题：自旋锁**自旋等待的时间必须要有一定的限度**，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

原子类里面的实现就是用了自旋锁：`do... while()`实现的

自旋锁在JDK1.4.2中引入，JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。

自适应意味着**自旋的时间（次数）不再固定**，而是由**前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

自旋锁另有特定的类：TicketLock、CLHlock和MCSlock

### 分段锁

锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，**当操作不需要更新整个数组时，就只锁数组中的一项就可以了。**

### 无锁/偏向锁/轻量级锁/重量级锁

针对synchronized进行优化使用的，主要是通过对象监视器在**对象头中的字段**来表明的。

无锁是最低级的，而重量级锁是最高级的，**锁状态只能升级，不能降级**

#### 无锁

不对资源进行锁定，所有的线程都能访问并修改同一个资源，但是同时只有一个线程能修改成功

——CAS原理和应用的原子类就是无锁的。无锁无法全面替代有锁数据结构，但是无锁在某些场合下性能是很高的

#### 偏向锁

是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。

因为经过分析在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下**尽量减少不必要的轻量级锁执行路径**，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，**线程不会主动释放偏向锁**。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

偏向锁在JDK 6及以后的JVM里是默认启用的

#### 轻量级锁

是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过**自旋的方式尝试获取锁**，不会阻塞，提高性能。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当**自旋超过一定的次数**，或者一个线程在持有锁，一个在自旋，又有**第三个来访时**，轻量级锁升级为重量级锁。

#### 重量级锁

是指当锁是轻量级锁时，当自旋的线程**自旋了一定的次数后**，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。

ps：synchronized的底层实现原理

先了解两个概念：

- 对象头：

  给同步资源加锁，就是激活存在**Java对象头里面的**，

  而对象头：在HotSpot虚拟机来说，对象头主要包括：**Mark Word（标记字段）、Class Pointer（类型指针）**

  Mark Word：默认存储对象的**HashCode，分代年龄和锁标志位信息**。都是与对象自身定义无关的数据，所以被设计为非固定的数据结构以便在极小的空间内存存储尽量多的数据。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间

  ClassPoint：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是**哪个类的实例**。

- monitor：一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为**内部锁或者Monitor锁**。

  monitor是线程的私有数据结构。每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个**Owner字段存放拥有该锁的线程的唯一标识**，表示该锁被这个线程占用。

synchronized是通过monitor来实现线程同步的，而Monitor是依赖底层的**互斥锁**来实现同步的

四种锁状态对应不同的MarkWord内容

| 锁状态   | 存储内容                                                 | 存储标记 |
| -------- | -------------------------------------------------------- | -------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁               | 01       |
| 偏向锁   | 偏向的线程id、偏向的时间戳、对象分代年龄、是否启用偏向锁 | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                     | 00       |
| 重量级锁 | 指向互斥量（即互斥锁）的指针                             | 10       |



### 监视器锁

synchronized的实现方式，使用monitorenter和monitorexit来实现。

### mutex锁

互斥锁，LockSupport.part()底层是通过mutex实现的。

