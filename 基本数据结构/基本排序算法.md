# 基本排序算法

## 1. 快排⭐

面试最常考的算法

采用的思想：**分治**的思想，是**不稳定**的算法

1. 在数据集之中，选择一个元素作为"基准"（pivot）；
2. 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边；
3. 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止

```java
public class Main{
    private static int partition(int[] nums, int left, int right){	// 用来进行划分——分
        int pivot = nums[left];			// 以最左边的元素为基准
        while(left < right){
            while(left < right && nums[right] >= pivot) right--;			// 从后开始找第一个小于pivot的数，要将其换到前面
            if(left < right) nums[left++] = nums[right];		// 先满足if，表示是while后面的条件不满足才出来的
            while(left < right && nums[left] < pivot) left++;		// 同上的操作，将第一个大于pivot的数换到后面
            if(left < right) nums[right--] = nums[left];
        }
        nums[left] = pivot;			// 循环结束后，left=right，那么该位置就是pivot的最新位置
        return left;
    }
    private static void quickSort(int[] nums, int left, int right){			// 治
        if(left > right) return;
        int mid = partition(nums, left, right);			// pivot的位置已经定下来了，所以下面不用再考虑它了
        quickSort(nums, left, mid - 1);			// 递归调用，注意边界
        quickSort(nums, mid + 1, right);
    }
    public static void main(String[] args){
        int[] nums = new int[]{3, 4, 4, 6, 6, 8, 9, 10};
        quickSort(nums, 0, nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }
}
```

### 时间复杂度：

时间复杂度主要跟递归深度有关：

最好的情况：就是划分的很均匀，递归树的树深为O(logN)，而每次操作都需要对整个数组进行比较（树的每一层都需要进行整个数组的比较）那么整体的时间复杂度为**O(NlogN)**

最坏的情况：数组本身是有序的，可以是逆序or顺序，那么每次划分，都是一边为空，一边为满，每次只能确定一个值，所以时间复杂度退化为$O(N^2)$

为了防止这种情况的出现，需要**巧妙地设定基准值**，我们一般都是选择数组头or数组尾，而在实际应用方面是用到了很多策略来选择的。

### 改进

当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大，所以基准值的选择会影响整体的效率。

最理想的方法是，每次选择的基准恰好能把待排序序列分成两个等长的子序列。

常见的方法：

1. **固定基准元**：每次partition都是选择确定位置的数字作为pivot

   适用场景：如果输入序列是随机的，那么处理时间是可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割，每次划分只能使待排序序列减一，时间复杂度为$O(N^2)$，所以此时不能用此种方法

2. 随机基准元：相对安全的策略，每次partition的基准元的位置是随机的，所以不容易出现很差的分割结果。

   在整个数组数字全相等时，仍然是最坏情况，时间复杂度是$O(n^2)$

   实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。

3. 三数取中：针对上面两种情况都存在最坏的情况，所以使用左端、右端和中心位置上的三个元素的中值作为基准元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约5%的比较次数。

对于很小的数组（N<=20）,快速排序不如插入排序好。因为，快速排序存在递归，而插入排序不需要递归，所以开销比较少。所以当left、right的范围在10以内，可以采用插入排序

参考：

1. https://blog.csdn.net/liuyi1207164339/article/details/50827608

partition还有很多种写法：

1. 交换法：找到后面第一个小于pivot的数字、再找到前面第一个大于pivot的数字，然后进行交换。**边界条件是i<=j**；循环结束时i>j，此时j指向小于pivot的数，那么j和pivot进行交换

```java
private static void swap(int[] nums, int i, int j){			// 辅助方法
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
private static int partition_swap(int[] nums, int left, int right){
    int pivot = nums[left];
    int i = left + 1, j = right;
    while(i <= j){
        while(i <= j && nums[j] > pivot) j--;           // 右边找到第一个不大于的pivot的结点
        while(i <= j && nums[i] < pivot) i++;           // 左边找到第一个不小于pivot的结点
        if(i <= j) swap(nums, i, j);                // 将它们进行交换，那么小于pivot的结点就在前面了
    }
    swap(nums, left, j);        // 跳出循环时。i>j，j指向了小于pivot的数，i指向了大于pivot的数
    return j;
}
private static void quickSort(int[] nums, int left, int right){
    if(left > right) return;                // 防止partition报错
    int mid = partition_swap(nums, left, right);
    quickSort(nums, left, mid - 1);
    quickSort(nums, mid + 1, right);
}

int[] nums = new int[]{2, 1, 6, 4, 5, 0, 3, 50};
quickSort(nums, 0, nums.length - 1);			// 调用
```

2. 一边挖坑一边填坑：第一个挖的坑就是pivot所在的地方，默认就是left，然后从右边开始循环，找到第一个小于pivot的结点填坑到前面挖的坑，那么该结点就又存在一个坑；然后，从左边开始循环，同样的填坑和挖坑。边界条件时left < right，此时left和right相等，该位置就是pivot要填上的坑

```java
private static int partition_fill(int[] nums, int left, int right){
    int pivot = nums[left];
    while(left < right){
        while(left < right && nums[right] > pivot) right--;
        if(left < right) nums[left++] = nums[right];
        while(left < right && nums[left] < pivot) left++;
        if(left < right) nums[right--] = nums[left];
    }
    nums[left] = pivot;         // 跳出循环时，left = right,该结点就是pivot的插入点
    return left;
}
private static void quickSort(int[] nums, int left, int right){
    if(left > right) return;                // 防止partition报错
    int mid = partition_swap(nums, left, right);
    quickSort(nums, left, mid - 1);
    quickSort(nums, mid + 1, right);
}

int[] nums = new int[]{2, 1, 6, 4, 5, 0, 3, 50};
quickSort(nums, 0, nums.length - 1);			// 调用
```

3. 一趟扫描法：j负责一趟扫描，i负责维护小于和大于pivot的分界线，指向的是当前最后一个小于pivot的结点

```java
private static void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
private static int partition_scan(int[] nums, int left, int right){
    int pivot = nums[left];
    int i = left, j = left + 1;
    while(j <= right){
        if(nums[j] < pivot){
            i++;
            swap(nums, i, j);
        }
        j++;
    }
    swap(nums, left, i);
    return i;
}
```

参考：https://blog.csdn.net/Holmofy/article/details/71168530?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161603636716780269869141%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161603636716780269869141&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-71168530.pc_v2_rank_blog_default&utm_term=%E5%8F%8C%E8%BD%B4

## 2. 插入排序

当数组长度较小时，更优的是用插入排序，而不是前面的快速排序，主要原因是：快速排序存在递归

总结：时间复杂度为$O(N^2)$，是稳定的算法。

思想：

1. 将数组分为两部分：已排序的部分；未排序的部分。初始时，已排序的部分只有arr[0]。
2. 从index = 1开始，将每个结点从后向前遍历，找到第一个小于该结点的i，i+1就是index数组的插入位置。在遍历的时候，需要将大于index的数字都向后移动。

```java
public class Main{
    private static int[] insertSort(int[] nums){
        int[] arr = Arrays.copyOf(nums, nums.length);       // 非原地修改数组
        for(int i = 1; i < arr.length; i++){
            int temp = arr[i];      // 待插入的结点
            int j = i;              // 查找适合的插入点
            while(j > 0 && temp < arr[j - 1]){         // 找到第一个不超过temp的位置，此时j就是插入点
                arr[j] = arr[j - 1];            // >temp的结点都向后移动一位
                j--;
            }
            if(j != i) {         // 如果插入结点就是i，表明并没有发生移动，即前面的数组都是不超过temp的值，而不需要重复填充了
                arr[j] = temp;
            }
        }
        return arr;
    }
    public static void main(String[] args){
        int[] nums = new int[]{2, 1, 6, 4, 5, 0, 3, 50};
        int[] arr = insertSort(nums);
        System.out.println("arr = " + Arrays.toString(arr));
    }
}
```

## 3. 归并排序⭐

## 4. 堆排序⭐

## 5. 桶排序⭐

## 6. 冒泡排序

## 7. 基数排序

