# 进程 & 线程

# 1. 进程

## 1.1 概念

概念：进程是资源分配的单位

进程包含：代码段 + 数据段 + 程序计数器 + 堆

注意：

1. **程序本身不是进程**，程序是被动的实体；进程是活动实体。
2. 多个进程可以执行同一个程序，但是它们分别是单独的执行序列。
3. 进程本身也是一个环境，可以来执行其他代码，例如JVM，本身是一个进程，但是它可以解释Java程序并执行。

### 1.1.1 进程状态

基本：5态（不同的OS，有不同的状态，但是基本的都有）

创建态new：正在创建

运行态running：获得cpu，正在执行

就绪态ready：等待cpu

等待态waiting：等待发生某个事件

终止态terminated：进程执行完毕

（注意和Java的线程状态有所不同，没有阻塞态，是合并在等待态中，Zephyr中存在挂起状态，suspend）

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210329192126246.png" alt="image-20210329192126246" style="zoom: 80%;" />

### 1.1.2 进程控制块

俗称PCB，内容有：

1. 进程状态：上面的5态
2. 程序计数器：PC，指向**下一个**要执行的指令的地址
3. CPU寄存器：包括通用寄存器、栈指针、累加器等，如果发生中断需要和PC（也是一个寄存器）都压入栈中进行保存；调度回来后需要恢复，实际上这边应该是存储寄存器在栈的指针
4. CPU调度信息：更调度相关的，包括优先级、调度队列等，具体是看OS的调度策略
5. 内存管理信息：跟内存系统相关。包括内存基地址、界限寄存器
6. 记账信息：使用CPU的时间、时间期限等统计数
7. I/O状态信息：包括占用的I/O列表、打开文件的列表

在Zephyr/Linux中活动的进程都是用一个双向链表存储的，用current指向当前进程。

## 1.2 进程调度

会有一个**进程调度器**来选择哪一个ready进程去获得CPU。（进程调度器只是概念，底层是由代码和数据结构组成的一个调度机制）

### 1.2.1 进程队列

系统中存在很多队列：进程队列——存放所有存活的进程的；就绪队列——存放所有等待CPU的进程；设备队列——等待特定IO设备的进程的——一般称为阻塞队列，它们是因为拿不到资源所以被挂在该资源的队列上的

进程可以分为：

- I/O密集型：执行I/O比执行计算的时间要多
- CPU密集型：执行计算较多

### 1.2.2 进程调度

调度方式分为：长期调度程序 和 短期调度程序：

- 长期调度程序：将进程从下·磁盘等外部设备的缓冲池中加载到内存。执行频率低，可能一个进程执行完成才有一个新的进程加载到内存中。

  主要是用来控制内存中的进程数目，在实时系统、分时系统中通常不用（Zephyr没有）

- 短期调度程序：从ready进程中选择进程获得CPU。执行频率高，所以选择需要快速，例如O(1)时间复杂度

长期调度程序需要对这两类进程做好均衡，如果I/O密集型进程太多，导致CPU利用率较低

后面又增加一个中期调度：可以将进程从内存中换出，后面又可以换入（长期调度程序只能一次加载，直到进程执行完成之后都不会切出）

### 1.2.3 上下文切换

就是CPU从一个进程切换到另一个进程，那么前一个进程需要保存当前的状态，而另一个进程需要恢复到之前的状态

而这个状态就是进程的上下文：主要就是PCB中的信息：CPU寄存器的值、进程状态、内存管理信息等

上下文切换的时间跟硬件相关

## 1.3 进程的运行

### 1.3.1 进程的创建



### 1.3.2 进程的终止





# 2. 线程

## 2.1 概念

概念：调度的基本单位

**一个进程中可以有多个线程**，它们共享进程资源。

eg：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<img src="pic/thread.png" style="zoom:67%;" >

引入多线程的优势：

1. 响应性：对于交互程序采用多线程，即使一个线程阻塞了，但是其他线程还是可以继续执行的
2. 资源共享：进程之间只能进行共享内存和消息传递来传递信息，但是同一个进程内的线程可以直接使用资源
3. 经济：进程开销昂贵
4. 可伸缩性：线程可以在多个处理器上并行运行，而进程只能运行在一个CPU上

## 2.2 多线程模型

有两种方法来支持多线程：用户线程、内核线程。

- 用户线程：在内核上面，它的管理不需要内核支持
- 内核线程：线程直接受操作系统管理

下面看用户线程和内核线程的对应关系：

### 2.2.1 多对一模型

多个用户级线程对应一个内核线程，如果内核线程被阻塞，那么整个进程就被阻塞了。且不能用于并发系统

### 2.2.2 一对一模型

一个用户级线程对应一个内核线程，并发性更好，且可以用于SMP，但是，由于是一一对应，所以会生成许多内核线程，开销大

——大部分系统实现了

### 2.2.3 多对多模型

即多个用户及线程对应多个内核线程，用户级线程多一点，内核线程个数少一点——多路复用。

## 2.3 线程库

线程库是库函数的一种，就是为程序员提供创建和管理线程的API（注意和线程池做区分）

实现线程库函数有2种方法：

1. 在用户空间提供一个没有内核支持的库

   那么API所有代码和数据结构都存放在用户层，所以使用该API只能算是本地调用，而非系统调用

2. 由操作系统直接提供支持的内核级的库

   API代码和数据结构都存放在内核层，使用该API就是系统调用

常见的线程库API：POSIX Pthreads、Windows、Java

- Pthreads：提供用户级或内核级的库
- Windows：内核级的库
- Java：采用宿主的线程库

## 2.4 多线程问题

### 2.4.1 系统调用fork()\exec()

`fork()`是在进程中，用来创建一个单独的重复的进程。

而如果一个线程`fork()`，那么UNIX系统存在两种解决方案：

1. 新进程会复制所有该进程中的线程
2. 新进程只会复制调用了fork()的线程

如果调用了exec()，那么指定的程序会替代整个进程，包括里面的线程。

### 2.4.2 信号处理

在UNIX中，信号用来通知进程某个特定事件已经发生。

信号可以是同步的 or 异步的，取决于事件的来源

事件的处理模式：

- 信号由特定事件发生而产生
- 信号是被传递给某个进程
- 进程一旦收到信号后，需要马上执行

同步信号：eg：非法访问 or 除零，某个进程一旦进行上面的操作就会产生信号，信号会发给自身进程

——同步信号是直接传递给自身

异步信号：其他程序产生的，eg：定时器到期。

但是在多线程的进程下，信号如何传递比较复杂：

- 信号到所适用的线程
- 信号到进程内的每个线程
- 信号到进程内的部分线程

### 2.4.3 线程撤销

线程完成之前终止线程。

场景：多个线程并发获取某个数据，一旦一个线程收到数据后，其他线程应该立即撤销

- 异步撤销：线程立即终止目标线程
- 延迟撤销：目标线程不断检查自身是否应该终止——自己终止自己（类似于Java的中断）

## 2.5 线程的实例

### 2.5.1 Windows线程

Windows支持多线程，且用户级线程和内核线程支持一对一映射

线程包含的内容：

- 线程ID：tid
- 寄存器组：CPU的寄存器，来表示处理器的状态
- 用户栈/内核栈
- 私有存储区域：存储运行时库和动态链接库

被称为线程上下文

线程含有的数据结构：

- ETHREAD：执行线程块，线程的指针、线程的程序地址和KTHREAD的指针
- KTHREAD：内核线程块，线程的调度和同步信息，内核栈和TEB指针
- TEB：线程环境块

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210330194354169.png" alt="image-20210330194354169" style="zoom:67%;" />

### 2.5.2 Linux线程

Linux并不区分线程和进程。其实统一用task来表示，而不是线程 or 进程。

系统中每个任务都有一个唯一内核数据结构，只是包含了一系列的指针，指向存储数据的指针，eg：打开的文件列表、虚拟内存等

# 3. 进程调度

## 3.1 调度的概念

由于存在多个进程，如果一个进程因为执行完成/要等待IO等信息，而暂时不占用CPU，那么需要切出去给另外一个进程去使用CPU，这个就引发了调度

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 3.2 调度程序

这个调度就是：**短期调度程序**，直接从内存中选择一个就绪的进程获得CPU执行。

### 3.1.1 抢占式 & 非抢占式

引发调度的时机：

1. 进程的状态从running变成waiting
2. 进程执行完成，变成terminated状态
3. 进程从等待状态变成就绪状态，eg：IO到来
4. 进程从running状态变成ready状态，eg：出现中断、时间片到期

如果系统中调度状态只能发生在1、2中间的，那么就是**非抢占式调度/协作式**，即一个进程一旦获得CPU，就会一直占用CPU，直到执行完成或者状态变成waiting状态。（中断不算在抢占内）

抢占调度：4个状态均能发生。

但是抢占调度可能会存在竞争问题，例如对共享变量的修改等，从而导致操作混乱，结果不确定。

### 3.1.2 调度程序

调度程序是一个模块，它用来且CPU，主要工作有：

- 上下文切换
- **切换到用户模式**
- 跳转到用户程序的合适位置，然后重新开始执行

——这些操作必须要快，因为调度耗时是无意义的，该切换时间被称为**调度延迟**

### 3.1.3 调度准则

就是衡量调度程序优劣的

1. CPU的使用率：要求CPU尽可能地忙碌
2. 吞吐量：单位时间内，进程的完成数量
3. 周转时间：就是进程从提交到从完成花费的总时间
4. 等待时间：这个针对的是在就绪队列中等待执行的时间
5. 响应时间：针对交互系统，发送一个请求到响应该请求的时间

需要根据场景进行优化，不可能做到所有最好。

## 3.3 调度算法

调度算法解决的是：ready队列中选择一个合适的进程获得CPU

### 3.3.1 批处理系统

批处理系统没有太多的用户操作，在该系统中，**调度算法目标是保证吞吐量和周转时间**（从提交到终止的时间）。

#### 3.3.1.1 先来先服务FCFS（非抢占的）

**非抢占式的调度算法**，按照请求的顺序进行调度。

优点：简单

缺点：平均等待时间很长

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

#### 3.3.1.2 短作业优先SJF（可选择）

**非抢占式的调度算法**，按估计运行时间最短的顺序进行调度。

理论上：短作业优先算法是**最优**的，因为给定一组线程，它的机制能保证等待时间最短。但是，难度在于计算作业的执行时间

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### 3.3.1.3 最短剩余时间优先SRTF

**最短作业优先的抢占式版本**，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 3.3.2 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

#### 3.3.2.1 时间片轮转RR（抢占的）

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

**时间片轮转算法的效率和时间片的大小有很大关系**：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

#### 3.3.2.2 优先级调度PS（可选择）

为每个进程分配一个**优先级**（PCB中存放），按优先级进行调度。

问题：存在饥饿（同SRTF）

解决方法：为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 3.3.2.3 多级反馈队列

基础：多级队列调度，是将线程划分成不同的类型，固定加入不同的队列，然后每个队列的调度策略可以不同，队列之间存在优先级

eg：**对于前台进程，可以采用FCFS调度，对于后台程序可以采用RR调度**，而队列之间采用固定优先级抢占机制。

多级反馈队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，**每个队列时间片大小都不同**，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

**每个队列优先权也不同**，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

进程在刚刚进入就绪队列时候会加入优先级最高的队列，如果在给定的时间片没有完成，就会加入到下一级队列的尾部.....

所以IO密集的进程、交互进程都会在优先级高的队列上，而CPU密集的进程会被逐渐向下移。

为了防止饥饿，会将等待时间很久的进程移到更高优先级的队列上。

可以将这种调度算法看成是**时间片轮转调度算法和优先级调度算法的结合**。

<img src="pic/MFQ.png">

### 3.3.3 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为**硬实时和软实时**：

- 硬实时：必须满足绝对的截止时间。
- 软实时：可以容忍一定的超时，关键进程会优先于非关键进程，但是不能保证在要求时间内结束

#### 3.3.3.1 最小化延迟

eg：无人驾驶车辆在发现行人的时候，需要制动，那么发现行人到操作的时间就是一个事件延迟

有2类延迟：中断延迟、调度延迟

- 中断延迟：CPU在收到中断到执行中断处理程序中间的时间

  中断延迟中主要进行的操作：

  1. 完成当前正在执行的指令
  2. 确定中断类型
  3. 保存当前进程状态
  4. 加载特定的ISR执行

  <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210329231452449.png" alt="image-20210329231452449" style="zoom:50%;" />

- 调度延迟：从停止一个进程到重新启动一个进程的时间（由于在调度过程中需要操作内核的部分信息，所以需要禁止中断）
  降低这种延迟的方式：提供抢占式内核（因为内核可以抢占，所以经常需要进行上下文切换，所以从性能考虑，调度延迟时间要求很短，所以相比较之下，抢占式内核的调度延迟要小于非抢占式内核的）

#### 3.3.3.2 优先级调度

优先级越高表明越要紧急处理，所以优先级调度是合理的。加上可抢占，那么就能处理中断

——但是只能保证软实时。

#### 3.3.3.3 单调速率调度

可抢占式、固定优先级的策略，来调度周期性任务。

每个周期性任务都会分配一个固定的优先级，周期越短优先级越高

#### 3.3.3.4 最早截止期限优先调度EDF

要求：进程在ready前需要告知截止时间，那么调度程序可以根据所有进程的截止时间进行调度。理论上是最佳的。

### 3.3.4 多处理器调度

多处理器调度比单处理更为复杂，没有最优的。

调度的方法分类：

- 非对称多处理：让一个处理器处理所有的调度决定、IO处理和其他系统活动，而其他处理器只是用来执行用户代码

  有主次之分（现在很多多处理器都这样）

  优点：不需要进行数据共享

  ——那么该调度就和单核调度一样

- 对称多处理：每个处理器自己进行调度，处理器们会访问共同的就绪队列，然后自行选择一个进程去执行

在SMP中，会试图避免一个进程从一个处理器迁移到另一个——处理器亲和性。

而OS来保证一个进程在一个处理器上避免迁移——软亲和性。

SMP的关键：保证负载均衡。

还有一种内存架构，能够影响处理器的亲和性：非统一内存访问架构NUMA——某个CPU访问内存速度比其他部分快

#### 3.3.4.1 负载均衡

负载均衡：将待处理的任务均衡的分配到多个处理器中。

对于每个处理器都有一个私有的就绪队列，那么负载均衡是需要的；如果是多处理器用一个公共就绪队列，那么没有复杂均衡的必要，一旦处理器空闲就会从中拉取进程。

负载均衡的两种方法：主要就是有一个任务周期性的检查每个处理器的负载，如果发现不平衡（到一定程度），就进行操作

- 推迁移：进程从高负荷的处理器推到低负荷的
- 拉迁移：低负荷的处理器从高负荷的处理器拉进程

——一般OS中是并行存在这两种的。

但是负载平衡，就会导致处理器亲和性消失，因为进程会在处理器间来回移动

## 3.4 调度算法的实例

### 3.4.1 Linux调度

Linux在2.6之后的版本用的是**完全公平调度程序**

Linux的调度是基于**调度类**的，每个线程都属于一个类，而每个类都有特定优先级，针对不同的类有不同的调度算法。

Linux会选择最高优先级调度类的最高优先级的任务，获得cpu。目前有两个类：

1. **CFS调度算法的默认调度类**
2. **实时调度类**

#### 3.4.1.1 CFS调度策略

**CFS没有严格的时间片轮转**，即不是按照优先级来划分时间片长度的，而是为每个任务都按照“友好值”分配一定比例的CPU执行时间（友好值低，优先级高）。并且，每个任务都会设定一个间隔时间，即下一次执行需要间隔一段时间。——目标延迟。

**CFS没有直接分配优先级**，而是记录**虚拟执行时间vruntime**，就是记录任务已经执行的时间，根据友好值来确定衰减因子（友好值低的，衰减更慢），从而确定下一段的时间片长度。

如果默认优先级的任务运行200ms，那么vruntime=200，那么较高优先级的任务运行200ms，那么它的vruntime <200，较低优先级的任务运行200ms，那么它的vruntime>200，所以只需要选择vruntime最短的就是优先级最高的任务

CFS的数据结构：**红黑树，基于vruntime的比较器**，每个可执行的任务都存放在红黑树上

所以根据二分搜索树的特性，最高优先级的任务就是在红黑树的最左边，查找时间是O(logN)，但是为了提高效率，会将最左侧结点缓存在一个变量中

#### 3.4.1.2 实时调度

采用SCHED_FIFO、SCHED_RR调度，实时调度类有更高的优先级。0~99范围内，普通任务是100~139，友好值-20~+19分配给普通任务

——优先级越高，数值越小

### 3.4.2 Windows调度

是基于优先级的、可抢占的调度算法。还有时间片轮转，类似于多级反馈队列

有**调度程序**专门来处理调度

线程有优先级：32级优先级：

- 可变类：1~15优先级
- 实时类：16~31优先级
- 优先级0：有且仅有一个线程，用来进行内存管理
- 还有一个空转线程

每个优先级均有一个队列，从最高优先级开始找，直到找到第一个线程开始执行。如果没有线程，那么执行空转线程

线程分类：（从上到下优先级逐渐降低）

- REALTIME_PRIORITY_CLASS：实时类——24（优先级基值）
- HIGH_PRIORITY_CLASS：高优先级类——13
- ABOVE_NORMAL_PRIORITY_CLASS：高于常规类——10
- NORMAL_PRIORITY_CLASS：常规类，通常都属于此类——8
- BELOW_NORMAL_PRIORITY_CLASS：低于常规类——6
- IDLE_PRIORITY_CLASS：空转类——4

除了实时类，其他类的线程优先级都是可变的

给定了线程的类，而该线程也还有一个相对优先级：

- TIME_CRITICAL
- HIGHEST
- ABOVE_NORMAL
- NORMAL
- BELOW_NORMAL
- LOWEST
- IDLE

（和上面的类似）

——**每个线程都有一个优先级的类型和在该类型中的相对优先级**

一个线程的时间片用完后，线程被中断，如果它属于可变优先级，那么降低其优先级，但是不会低于基准优先级。然后，一个线程从等待队列回到ready队列，其优先级会升高，升高的大小取决于在等待什么资源，如果是IO资源，那么提升最多，磁盘次之。

那么IO密集型的线程能够保持忙碌，且在空闲的时候CPU密集型程序可以得到执行。

Windows对于交互程序做了特殊的策略：对于NORMAL_PRIORITY_CLASS，将其分为**前台进程——屏幕上选择的进程和后台进程——屏幕上未选择的进程**，当一个进程移动到前台，会增加其时间片，为原来的3倍

Windows7下增加了用户模式调度，就是允许应用程序在内核外创建和管理线程，对于有大量线程的应用程序，由于不要进行系统调用，所以性能较好。
