# 额外知识：系统的内存布局

目前有的概念：

程序代码：又称文本段（代码段）

进程内容：PC、寄存器（与CPU相关的）、进程栈（临时数据，函数参数、返回地址、局部变量）、数据段、**堆（进程在运行的时候申请的内存块）**

## 1. Linux 进程地址空间布局

在 32 位系统中，这个内存空间拥有 4GB的寻址能力。

Linux 默认情况下将**高地址的 1GB 空间分配给内核**，称为内核空间。（Windows默认是2G，也可以配置为1GB）

用户使用的剩下的 2GB 或 3GB 的内存空间称为用户空间。

应用程序无法直接访问内核区

why要区分 kernel space 和 user space？

1. 做好划分：操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的
2. 分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性，并且管理上很方便；
3. 将用户的数据和系统的数据隔离开，就可以对两部分的数据的**访问进行控制**

### 用户空间中包含的内容有：

**栈区**：维护函数调用的上下文，离开了栈，函数调用就无法实现；大小用MB来计算

**动态链接库映射区**：映射装载的动态链接库。在 Linux 下，如果可执行文件依赖其它共享库，那么系统就会为它在从 0x40000000 开始的地址分配相应的空间

**堆区**：程序动态分配的内存区域，即用malloc申请的内存块都在这里

**可执行镜像文件**：存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里

**保留区**：对内存中受到保护而禁止访问的内存区域的总称。例如大多数操作系统中，极小的地址通常都是不允许访问的，如 NULL，C 语言将无效指针赋值为 0 也是这个考虑。

还有：代码段、初始化数据段、未初始化数据段（BSS段）

<img src="pic/process_mem.jpg"  >

栈是由高地址向低地址增长。栈一般从高地址开始存储。

堆是由低地址向高地址增长。

当栈或堆现有的大小不够用的时候，它将按照图中的增长方向扩大自身的尺寸，直到预留的空间被用完为止。

### 代码段text

代码段中存放可执行的指令，为了保证不会因为堆栈溢出被覆盖，将其放在了**堆栈段下面**。

代码段是共享的。

代码段一般是**只读的**，这样程序执行时不能随意更改指令，也是为了进行隔离保护。

### 初始化数据段

数据段是一个程序虚拟地址空间的一部分，包括一**全局变量和静态变量**，这些变量在编程时就**已经被初始化**。

数据段是可以修改的

数据段可以细分为**初始化只读区**和**初始化读写区**：

eg：`const int m = 2;`是放在只读区，因为不能被修改了;

​		`int global = 3;`（全局变量），放在读写区，因为可被修改。

### 栈

在经典的操作系统里，**栈总是向下增长的**——即从高地址开始存储，不断向下扩展。

用**esp**表示栈顶指针

栈会保存一个**函数调用**所需要的维护信息，这常常被称为**堆栈帧**，包括如下信息：

1. 函数的返回地址和参数；
2. 临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量
3. 保存的上下文，包括在函数调用前后需要保持不变的寄存器

### 堆

在任意时刻，程序可能发出请求，需要申请 or 释放内存，申请的大小、申请的时间都是不确定的。

所以，需要设计出栈，在栈上分配和释放内存块

堆是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存，并自由地使用，这块内存在程序主动放弃之前都一直保持有效。

所以，在堆上申请的内存块需要显式申请和释放，即malloc() & free()搭配使用。

那么malloc的实现？

理论上：可以把进程的内存管理交给操作系统内核，每次malloc，都会去进行系统调用。——但是，性能很差，系统调用开销很大

好的做法就是：**程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间**，而具体来讲，管理着堆空间分配的往往是**程序的运行库**，即堆空间是批发，管理空间是零售。当申请的堆空间耗尽时，转而再去向OS申请新的堆空间。

除了可执行文件，共享库和栈之外，剩余的未分配的空间都可以用来作为堆空间。

程序向os申请堆空间**需要进行系统调用**：**brk() 统调用和 mmap() 系统调用**

- brk()系统调用：本质上就是去设置进程数据段的结束地址，即它可以扩大或者缩小数据段（bss + data）

  如果数据段的结束地址变大，即扩容，扩容后的空间就是作为堆空间

- mmap()系统调用：作用就是向操作系统申请一段虚拟地址空间，（堆和栈中间，称为文件映射区域的地方）**这块虚拟地址空间可以映射到某个文件**

glibc 的 malloc 函数的操作：

- 对于小于 128KB 的请求来说，它会**在现有的堆空间**里面，按照**堆分配算法**为它分配一块空间并返回；
- 对于大于128KB 的请求来说，它会使用 mmap() 函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间

#### 堆分配算法

**1、空闲链表法（即调用 malloc 分配）**

**2、位图法**：将整个堆划分为大量的块(block)，每个块的大小相同。然后用一张表来记录每个块的状态，请求时，总是分配整数个块的空间给用户，所以需要记录哪个是头（head）、其余为主体（body）。

**3、对象池**：把堆空间分成了大小相等的一些块，每次就直接返回一个块的大小。数据结构可以是链表 or 位图





## ps：

bss：存放程序中**未初始化的全局变量**的一块内存区域，是静态内存分配，**不保存在硬盘上，只是记录数据所需空间的大小**（占位符），程序开始执行之前，才分配且由内核进行初始化为0

data：存放程序中**已初始化的全局变量**的一块内存区域，是静态内存分配，保存在硬盘上，由.exec读取

——包含data段和bss段的整个区段此时通常称为数据区

text：存放程序执行代码的一块内存区域，在程序运行前就已经确定，并且内存区域通常属于**只读**（某些架构也允许可写），保存在硬盘上，由.exec读取

​		也有可能包含一些只读的常数变量，例如字符串常量等

——**一个程序本质上都是由 bss段、data段、text段三个组成的。**

text和data段都在可执行文件中，bss不在可执行文件中

参考：

1. https://zhuanlan.zhihu.com/p/107570048