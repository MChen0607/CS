# IO设备

这边只是做简单的理解，由于涉及到了中断，所以为了OS学习的完整性，所以必须要加上关于IO设备的总结

计算机的主要工作就是：IO和处理。

操作系统的IO功能是：管理和控制IO操作和IO设备

## 1. 概述

**操作系统提供了设备驱动程序模块，它能够为IO提供统一的设备访问接口**，这是一个标准接口。类似于操作系统给上层的应用提供了系统调用这个统一的接口，从而来实现应用程序调用OS功能。

## 2. IO硬件

### 2.1 概念

设备大致分为：存储设备、传输设备、人机交互设备

设备和计算机通过端口进行连接，如果**设备共享一组通用线路，该线路就是总线**。就是设备都挂载在同一个线路上。

典型的PC总线如下：PCI总线将处理器内存子系统连到快速设备。扩展总线接口连接的是相对较慢的设备，例如键盘、串口、USB。

<img src="pic\image-20210404174450433.png" alt="image-20210404174450433" style="zoom:80%;" />

**串行端口控制器**：是简单的设备控制器，它本质是一个芯片，该芯片用来**控制串口线路的信号**。

有的设备有内置的控制器，eg：磁盘内部带有磁盘控制器，它实现了某种协议，还能实现坏块的映射、高速缓存等。

**处理器控制控制器：**

处理器对控制器发送命令和数据传输：控制器有多个寄存器，用来控制信号和数据，而**处理器会通过读写这些寄存器的位模式来和控制器进行通信**。

- 处理器使用特殊的IO指令对IO端口地址传输一个字/字节。然后**IO指令触发总线线路，然后将IO指令传输到指定的IO控制器上**，然后将位移入或移出设备寄存器（端口地址是OS设定好的）
- 设备控制器可以支持内存映射IO，那么设备控制器的寄存器会被映射到处理器的地址空间，然后就将IO指令映射到对应的物理内存中。

eg：图形控制器（显示器），就是同时使用了上面两种技术，有IO端口完成基本控制操作；也有内存映射区域来存放要输出的屏幕内容

IO端口一般由4个寄存器组成：

- **状态寄存器**：主机可以读取的位，eg：设备是否正常；是否完成操作；数据输入寄存器是否有数据可以读取
- **控制寄存器**：由主机写入，可以用来更改设备的状态或启动命令，
- **数据输入寄存器**：主机可以读取的数据（它这边的输入是针对主机来说的，对于设备来说是输出）
- **数据输出寄存器**：主机写入的数据，可以交给设备的

数据寄存器一般有1~4字节，有些控制器还带有FIFO芯片，可以保留多个输入输出

### 2.2 轮询

可以使用两个位协调控制器就可以实现主机和设备之间的通信。

控制器设置状态寄存器的忙位，来表示当前设备的状态（处理器进行读取）

处理器通过命令寄存器的命令就绪位，表示要进行通信

eg：主机需要进行数据输出时，主机和控制器之间的握手过程如下：

1. 主机重复读取忙位，直到该位为0（表示上一次的操作完成）
2. 主机设置命令寄存器的写位，标志要写，并写出一个字节到数据输出寄存器
3. 主机设置命令就绪位
4. 控制器发现命令就绪位被设置，那么控制器设置为忙位
5. 控制器读取命令寄存器，看到是要写，然后从数据输出寄存器中读取数据，然后向设备进行操作
6. 控制器清除命令就绪位，清除状态寄存器的故障位，表示IO设备已经正确接收到信息；清除忙位表示操作完成。

每个字节的传输都要进行如下步骤。

可以发现，在步骤1中，如果设备一直没有清除忙位，那么主机就一直**处于忙等待/轮询的状态**。如果该设备的操作时间很长，那么CPU一直在空转，浪费了CPU资源。但是，也不能随意切换其他进程进行操作，因为不知道数据何时会来，而有些设备要求能够尽快的读取数据输入寄存器的内容，否则数据会丢失（eg：键盘）。

### 2.3 中断

针对上面的忙等待问题，就有了中断。

中断的基本工作原理：**CPU硬件有一条线，被称为中断请求线IRL**。**CPU在执行完每条指令之后都会去检测IRL。**

当CPU检测到控制器已经在IRL上发送了一个中断请求信号，那么CPU会保存当前进程的状态，然后跳转到**固定内存位置的中断处理程序去执行**（注意，中断处理程序不是一个单独的进程，而只是一段代码，但是由于需要用到寄存器等，所以在开始执行之前都需要保存当前进程的上下文）

中断处理程序主要工作：

1. 确定中断原因，就是分析发生中断的类型、该选择何种处理程序
2. 执行对应的具体处理程序
3. 执行状态恢复
4. 返回终端指令，然后CPU回到中断之前的执行状态

——设备控制器通过中断请求线发送信号而**引起中断**，CPU**捕获中断**，并且**分派到中断处理程序**，中断处理程序通过处理设备而**清除中断**。

<img src="pic\image-20210404195520704.png" alt="image-20210404195520704" style="zoom: 67%;" />

这个是一个基本的中断控制机制，是CPU异步响应中断。而实际上的计算机使用的是更为复杂的中断机制，eg：中断是可以延迟处理的，中断有分优先级等

大多数CPU有两条中断请求线，一条是可屏蔽中断的；一条是不可屏蔽中断的，保留用于不可恢复的内存错误等事件——一定要能够处理到的。

中断机制接收一个地址，而该地址会指示具体的中断处理程序——**中断向量**，中断向量保存了专门的中断处理程序的内存地址，那么不需要再遍历所有设备找到中断源，即可以直接根据index找到专门的中断处理程序。

实际上，计算机的设备和中断处理程序 是 多于中断向量内的地址，**采用中断链**，会将中断链表上的中断处理程序都进行调用，直到发现一个可以处理请求的程序。——类似于哈希表，找到哈希值对应的链表之后，开始遍历链表找到需要的结点。

eg：Intel Pentium的中断向量表：

<img src="pic\image-20210404202254461.png" alt="image-20210404202254461" style="zoom:80%;" />

0~31是非屏蔽中断，可以表示各种错误条件的信号，内部产生的错误；32~255是可屏蔽中断，用来表示设备中断信号

中断机制还实现了一个中断优先级，能够让高优先级的中断抢占低优先级的中断（zephyr里面不支持），并且可以延迟处理低优先级的中断而又不需要屏蔽中断信号。

现代操作系统，中断的交互：

- 在计算机刚开始启动的时候，操作系统会对总线进行探测，从而判断有哪些设备，那么在中断向量表中安装相应的中断处理程序。
- 各种**设备控制器在准备好时，会发生中断**，表示命令已经完成、数据可用、设备故障已经处理完成

**中断机制可以处理异常**：eg：除0操作、内存的非法访问、用户模式下执行特权指令等

中断还有其他作用：

- 14-缺页错误：虚拟内存分页可以用中断来实现，缺页就会触发异常，当前进程被挂起，然后CPU去执行缺页错误处理程序，然后当前进程进入等待队列，而CPU会执行页面缓存管理，调度IO操作来获得页面，在这个期间CPU就调度另一个进程去执行，直到提示页面加载完成
- 系统调用：程序通过库函数来进行系统调用，eg：`malloc()`，库程序会将传递的参数创建数据结构放到栈中之后，然后执行**软中断/陷阱trap**，然后进程执行到陷阱指令时，中断硬件会保存用户进程的状态，然后切换到内核模式，然后分派到对应请求的内核程序。软中断的优先级低于设备中断（>255）

### 2.4 直接内存访问

前面涉及到处理器和控制器之间的通信，可以发现时一个字节一个字节进行串行通信的。对于大量的数据传输设备，显然这样的效率是不可接受的。所以将该任务交给另一个专用的处理器——**直接内存访问控制器DMA**，注意DMA本身是一个处理器，可以脱离CPU而进行单独工作。

主要步骤：内存到设备

- CPU将DMA命令写到内存，DMA控制器就知道了，那么启动传输

  命令包含：传输来源的地址指针，传输目标的地址指针，传输的字节数

- CPU去干其他事情了，DMA直接操作内存总线，将地址放到总线，然后进行传输

DMA和设备控制器进行的握手，包括**DMA请求和DMA确认**。

如果有数据需要传输的时候：设备到内存

- 设备控制器发送信号到DMA请求线路
- DMA控制器收到请求后，会占用内存总线，发送所需的地址到内存地址总线，并且发送信号到DMA确认线路
- 设备控制器收到DMA确认信号后，传输数据到内存，并且清除DMA请求信号。

——在DMA控制器占用内存总线时，CPU会暂时阻止内存访问，但是cache中的、辅助cache的数据项还是可以访问的。（周期窃取）

然后完成传输后，DMA控制器会发送中断

<img src="pic\image-20210404212647127.png" alt="image-20210404212647127" style="zoom:80%;" />

## 3. 应用程序IO接口

### 3.1 概念

不可能是直接去操纵不同设备的设备控制器，因为设备的特性不一样，操作方式不一样。

所以，操作系统先对设备进行分类，划分了一些通用类型，对于每个通用类型都涉及了一组标准接口，然后程序可以通过标准接口对设备进行控制。

而**差异都被封装到设备驱动程序**中了，而设备程序对上就是统一的接口，对下就是针对不同的设备定制实现。

——所以，设备驱动程序层：为内核的IO子系统隐藏设备控制器之间的差异。 

设备在很多方面有很大的差异：

<img src="pic\image-20210404213928386.png" alt="image-20210404213928386" style="zoom:80%;" />

主流的设备分类还是：块设备、字符设备、网络设备、内存映射文件访问

大多数操作系统还是提供了一个**逃逸：应用程序可以直接发送命令到设备控制器**

Unix：是`ioctl()`，就是应用程序可以调用任何一个设备驱动程序实现的功能，有3个参数：文件描述符：引用驱动程序管理的硬件设备来连接应用程序和设备驱动程序；整数：选择设备驱动程序实现的一个命令；内存中数据结构的指针：那么应用程序和驱动程序传输任何需要的数据。

### 3.2 块与字符设备

块设备：eg：磁盘驱动器。

块设备接口需要能够：`read()\write()`，如果支持随机访问，还要有`seek()`

字符设备：eg：键盘。

要能够`put()\get()`，还有输出设备：打印机等

### 3.3 网络设备

表现和磁盘的完全不一样。许多操作系统使用`socket`接口。

### 3.4 时钟和定时器

计算机带有硬件时钟：

- 获取当前时间
- 获取经过的时间
- 设置定时器，让在T时刻触发中断操作X

这个是针对操作系统和对时间敏感的应用程序。

还可以设计软件定时器：**可编程间隔定时器**

可编程间隔定时器：可以设置等待一段时间，然后触发中断。时间片轮转的调度程序就是用了该间隔定时器。磁盘IO子系统也是用间隔定时器刷新脏数据到磁盘。

（软件的定时器本质上还是用了硬件的时钟中断实现的，每个硬件中断都会更新当前时钟，所以软件计时器才能正确计时）

### 3.5 非阻塞与异步IO

阻塞IO，就是在执行了阻塞系统调用后，进程会被挂起进入等待状态，当系统调用完成后，会唤醒等待进程加入到就绪队列中。当该进程恢复执行时，会收到系统调用的返回值。

大部分的IO操作都是采用阻塞IO。

非阻塞的IO，eg：用户接口，用来接收键盘的输入和输出到屏幕；视频应用，从磁盘中读取帧并且解压显式到显示器中。

异步调用是非阻塞IO，是立即返回，不会进行等待

非阻塞IO和异步调用的区别：非阻塞调用read会立即返回任何可用的数据，可能为0，适合于键盘等场景

​													异步调用read是要求完成之后才能进行调用

## 4. 内核IO子系统

内核IO子系统是内核的一部分，是专门用来提供关于IO的服务的，eg：调度、缓冲、错误处理等

### 4.1 IO调度

调度一组IO需要有一个顺序来执行。

eg：三个应用程序对磁盘进行阻塞的读取调用，那么如果用SCAN算法，就是一个IO调度。

IO调度实际上就是对每个设备维护一个等待队列，如果操作该等待队列就是调度需要实现的

操作系统会实现一个设备状态表，维护所有设备的状态信息：每个条目就对应一个IO设备，含有设备类型、地址、状态等信息。

### 4.2 缓冲

- 缓解消费者和生产者的速度不匹配

  eg：一个很慢的操作不断产生数据，那么就将数据存放到缓冲区，等数据满了再将整个缓冲区写到磁盘中。并且最好用双缓冲区，那么一个向磁盘传输的时候，另一个还能写入数据

- 协调传输大小不一的数据的设备

  eg：TCP中的缓冲区

- 支持应用程序的IO复制语义

  应用程序希望将应用程序的数据缓冲区写到磁盘，可以先将数据缓冲区复制到内核内存缓冲区，然后内核缓冲区再将数据写入到磁盘

### 4.3 缓存cache

缓冲是保存了数据项的唯一的一组数据；缓存是提供了一组更快的副本，在其他地方还有一模一样的数据

主要是为了提高速度

### 4.4 假脱机 & 设备预留

假脱机是针对打印机这样的设备，只有处理完一个任务之后，才能进行下一个任务，而不能一会儿处理这个一会儿处理那个。

应用程序的输出会假脱机到一个单独的磁盘文件中，假脱机系统按照某个顺序进行排序。然后一次复制一个文件到打印机。

——这也是一种协调并发输出的方式。

### 4.5 错误处理

IO子系统会对错误进行处理，

eg：磁盘read/write故障，会尝试进行read/write重试；

网络send故障，会进行send重试。

IO系统调用一般会返回状态信息，如果出现故障，大多数返回错误号或代码，如果错误还可以看系统错误日志。

也会跟踪错误频率，当出现错误增加时可以停用错误增加的设备。

### 4.6 IO保护

为了实现IO保护，定义所有的IO指令为特权指令，用户需要进行系统调用才能通过操作系统来发送IO指令。

操作系统会在监控模式下检查请求是否合法，但是内核也不能随便拒绝用户访问。

## 5. IO请求转换为硬件操作

以UNIX为例，它通过常规文件系统名称来表示设备名称，并且没有在路径中明确区分设备部分，即**路径中没有涉及到设备名称部分**

UNIX有一个安装表，将路径名称的前缀和特定设备名称关联。

UNIX解析路径名，会根据安装表中的名称进行最长前缀匹配——那么就能找到对应的设备。

举例：进程阻塞读请求的整个IO流程：

1. 针对的是之前已经打开的文件，进程调用阻塞的**系统调用**read()

2. 内核系统调用代码 先检查 参数是否正确。如果输入的数据已经在缓存中了，那么直接将数据返回，传递给进程，并完成IO请求

3. 否则执行物理IO请求，会将进程从running态切换到等待状态，并且加入到设备的等待队列，并且进行IO调度

   IO子系统会发送请求到设备驱动程序，该请求可以通过子程序调用或内核消息来传递

4. 设备驱动程序分配缓冲区空间，用来接收数据。并且调度IO。

   然后设备驱动程序通过写入设备控制器的寄存器，然后对设备控制器发送命令

5. 设备控制器控制设备，然后进行数据传输

6. 设备驱动程序会轮询检查状态和数据，or DMA传输数据到内核内存，在传输完成后会产生中断

7. 中断处理程序接收中断，并保存数据，向内核的设备驱动程序发送信号并从中断返回

8. 设备驱动程序受到信号，确定IO请求是否完成，并对内核子系统发送信号提示请求完成

9. 内核受到信号，将进程从等待队列移到就绪队列

<img src="pic\image-20210405093311111.png" alt="image-20210405093311111" style="zoom:80%;" />

## 6. 性能

IO是系统性能的一个重要性能

中断，是一个很昂贵的任务；由此导致的上下文切换代价也比较大。

改善IO效率，可以从如下几方面考虑：

- 减少上下文切换的次数
- 减少设备和内存之间数据传递的次数
- 通过大传输、智能控制器、轮询等减少中断次数
- 通过DMA等智能控制器等来承担数据复制，从而增加并发
- 将设备的处理程序尽量短，可能用硬件执行原语，从而实现CPU和总线的并发

