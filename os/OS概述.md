# 操作系统概述

计算机系统的组成：硬件、操作系统、应用程序、用户

OS提供的服务：

- 用户界面：几乎所有OS都有用户界面，有3种形式
  - 命令行界面CLI
  - 批处理界面：命令和控制这些命令的指令可以编成文件，从而执行
  - 图形界面GUI
- 程序执行：能加载程序到内存执行
- I/O操作
- 文件系统操作
- 通信：计算机内部的进程间通信，和计算机之间通过网络的通信
- 错误检测：对于错误要能发现，并做出应对
- 资源分配
- 记账：统计用户使用资源的类型和数量
- 保护和安全

# 1. 概述

操作系统的目标：

- 有效性：
  - 提高资源利用率，eg：更有效的利用CPU，更有效的存储数据等
  - 提高系统吞吐量
- 方便性：是计算机系统更容易被使用
- 可扩充性：方便增加模块和功能，方便修改旧的模块
- 开放性：遵循一个统一的标准。特别是遵循开放系统互连(OSI)国际标准，那么设备之间能够彼此兼容，方便互联

操作系统的作用：

1. 是用户和计算机硬件之间的接口：

   用户通过OS来使用计算机系统。

   用户用如下3种方式使用计算机：

   - 命令：OS提供了一组联机命令接口，用户输入命令之后，OS会响应
   - 系统调用：用户在应用程序中调用该方法来实现和OS的通信，并且取得服务
   - 图形窗口方式，Windows

2. OS是计算机系统资源的管理者

   计算机资源分为四类：**处理器、存储器、I/O 设备以及信息**(数据和程序)

   OS就是协调好这些资源的使用的，如果有多个程序同时需要这些资源，则需要合理分配

3. OS实现了对计算机资源的抽象

   用户直接使用OS给的资源接口，而不必关注底层是如何实现的，且不同资源之间的差别

实时系统：系统能够及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。

## 1.1 OS基本特征

### 1.1.1 并发

并发是指宏观上在一段时间内能同时运行多个程序（一个时刻只有一个），而并行则指**同一时刻**能运行多个指令。

并行需要硬件支持，如多流水线、**多核处理器**或者分布式计算系统。

操作系统通过**引入进程和线程，使得程序能够并发运行**：

- 进程，在系统中能独立运行并作为资源分配的基本单位
- 线程，作为独立运行和独立调度的基本单位。把进程作为分配资源的基本单位

### 1.1.2 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用**同步机制来实现互斥访问**。

### 1.1.3 虚拟

虚拟技术把一个**物理实体转换为多个逻辑实体**。

主要有两种虚拟技术：**时（时间）分复用技术和空（空间）分复用技术**

- 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

- 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

  （还有，虚拟磁盘技术，只有一个物理硬盘，但是可以将硬盘虚拟为多个虚拟磁盘，将硬盘划分为多个卷，然后将这几个卷安装在对应的逻辑驱动器上，然后就有了虚拟硬盘，但是是一一对应的）

### 1.1.4 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

## 1.2 基本功能

### 1.2.1 进程管理

- 进程控制（状态变迁的控制）

  创建进程、销毁进程，以及控制进程在运行过程中的状态转换

- 进程同步

  进程是异步的，而为了多个进程一定程度上的有序，所以要设置**同步机制**：主要就是为了**多个进程的运行协调**，两种协调方式：

  - 进程互斥：对于临界区的访问
  - 进程同步：合作才能完成的，需要同步执行的次序

- 进程通信

  主要是相互合作的线程进行信息交换

- 死锁处理

  主要是互斥时用到了锁，而会产生的死锁问题的解决方案

- 处理机调度

  按照一定规则选择线程去获取CPU

### 1.2.2 内存管理

CPU只能从内存中加载指令，所以程序必须放在内存中，内存是RAM（掉电失数据，随机存储的）

由于内存的容量很小、且易失性，所以需要外存来扩充内存，用来永久存储大量数据

ps：存储设备的级别：寄存器 > cache > 内存（RAM） > 固态磁盘 > 硬盘 > 光盘 > 磁带（ROM）

- 内存分配

  现在采取的有两种方式：静态分配、动态分配

  静态分配：每个作业的内存空间是在作业装入时确定的；在作业装入后的整个运行期间，不允许该作业再申请新的内存空间，也不允许作业在内存中“移动”

  动态分配：基本内存空间也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动”。

- 地址映射

  程序编译之后，地址都是从0开始的，而其他地址都是相对于该0开始计算的，这些地址被称为**逻辑地址（相对地址）**。

  而实际内存中的地址是**物理地址**。

  而在实际内存中不可能所有程序的地址都是从0开始的。

  ——逻辑地址和物理地址不相一致，所以必须要经过内存映射才能完成

- 内存保护与共享

  程序都只在自己的内存空间内运行，彼此互不干扰

  一种比较简单的内存保护机制是**设置两个界限寄存器**，分别用于存放正在执行程序的上界和下界。系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。

  ——如果是纯软件实现，程序的运行效率较差，于是现在的越界检查都是由硬件实现，对越界后的处理由软件实现

- 虚拟内存：即地址映射里面的

- 内存扩充

  并非是去扩大物理内存的容量，而是借助于虚拟存储技术，从逻辑上去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多

  - 请求调入功能：允许在装入一部分用户程序和数据的情况下，便能启动该程序运行。
    在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向OS发出请求，由OS从磁盘中将所需部分调入内存，以便继续运行。

    ——即调入是从磁盘（更大）到内存（较小）

  - 置换功能：内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至盘上，以腾出内存空间，然后再将所需调入的部分装入内存。

### 1.2.3 文件管理

文件管理的主要任务是对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性

- 文件存储空间的管理

  需要由文件系统对诸多文件及文件的存储空间实施统一的管理。其主要任务是为每个文件分配必要的外存空间，提高外存的利用率，并能有助于提高文件系统的存、取速度。

- 目录管理

  为了使用户能方便地在外存上找到自己所需的文件，通常由系统为每个文件建立一个目录项。目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件

- 文件读写管理和保护

### 1.2.4 设备管理

管理计算机系统中所有的外围设备。

对于少量的数据，可以使用IO中断；对于大量的数据移动，需要**直接内存访问**，只需要设置好缓冲、指针和计数器，设备控制器可以在本地缓冲和内存之间传送整块数据，而无需CPU干预。

任务：

- 完成用户进程提出的I/O 请求；
- 为用户进程分配其所需的I/O 设备；
- 提高CPU 和I/O 设备的利用率；
- 提高I/O 速度；
- 方便用户使用I/O 设备。

主要包括：

- 缓冲管理

  主要原因：CPU 运行的高速性和I/O 低速性

  于是在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法来改善系统的性能。

  不同系统有不同的缓冲区机制：单缓冲、双缓冲等

- 设备分配

  根据用户进程的I/O 请求、系统的现有资源情况以及按照某种设备的分配策略，为之分配其所需的设备

  系统中应设置设备控制表、控制器控制表等数据结构，用于记录设备及控制器的标识符和状态。

- 设备处理

  即设备驱动程序。其基本任务是用于实现CPU和设备控制器之间的通信，即由CPU 向设备控制器发出I/O 命令，要求它完成指定的I/O 操作；反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。

- 虛拟设备

## 1.3 系统调用

**系统调用是提供操作系统服务的接口**。程序员一般使用的是OS提供的系统调用接口API，而这些API会去调用实际的系统应用。（因为，这样的程序可移植性更高，即使在不同的系统，只要遵循同样的命名规则，例如POSIX标准，都可以直接移植过去；且API好用，而系统调用更为底层，更难用）

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而**陷入内核**，由操作系统代为完成。

<img src="pic/systemCall.png" style="zoom:74%;" >

陷入内核时，还需要将一定的参数传递给OS，而给OS传参的方式有：

- 寄存器传递（数量较少），在需要传递的参数较多时不适用；
- 将参数存放在内存的块或者表中，然后将该块or表的地址放在寄存器中传递；
- 数量较多时，**用压栈的方式将参数传递过去**（压入的时系统的栈），然后用到的时候弹出（所以，需要根据参数的使用次序来压栈）——这个方法，不限制参数的长度和数量

Linux 的系统调用主要有以下这些：（都在库libc中）

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |

### 1.3.1 进程控制

eg：创建、终止进程；正常、异常中止进程；加载、执行进程；获得和设置进程属性；超时等待，等待事件、等待信号；分配和释放内存；上锁等

### 1.3.2 文件管理

创建、删除文件；打开关闭文件；读取、写入、重定位文件；读取、设置文件属性

### 1.3.3 设备管理

操作系统控制的资源就是设备，存在物理设备，eg：磁盘、打印机等；存在虚拟设备，eg：文件

请求、释放设备；读取、写入、重定位；获得、设置设备属性；

### 1.3.4 信息维护

获得当前的时间、日期等，还能返回系统的其他信息，eg：当前用户数、操作系统版本、内存磁盘的可用量等

### 1.3.5 通信

消息传递模型和共享内存模型。

消息传递模型：进程通过相互交换信息来传递信息

内存共享模型：有一块多个进程可以访问的内存，然后一个写数据、一个读数据，但是需要注意并发操作的问题

创建、删除通信连接；发送、接收数据（对于消息传递模型）；创建共享内存；传递状态信息等

### 1.3.6 保护

设置资源权限；允许、拒绝用户访问请求

## 1.4 宏内核和微内核

### 1. 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

### 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而**降低内核的复杂性**。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

优点：可扩展性变强；增加系统可靠性；可移植性；为分布式系统提供支持

缺点：因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

微内核的基本模块：

- 进程（线程）管理
- 低级内存管理，例如逻辑地址和物理地址的转换、页表机制等保留，其他的页面置换等就放在外部实现
- 进程间通信

![img](https://camo.githubusercontent.com/e244b7965823da98c230d7b71038b8ee11dcb2e30b5e8fb1272dcd76008a889f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f325f31345f6d6963726f6b65726e656c4172636869746563747572652e6a7067)

## 1.5 中断分类

### 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

### 2. 异常

由 CPU 执行指令的**内部事件**引起，如非法操作码、地址越界、算术溢出等。

### 3. 陷入

在用户程序中使用系统调用。

# ps

前趋图(Precedence Graph)是一个有向无循环图，记为DAG，可以来描述进程之间执行的前后关系

事件发生会通过软、硬件的中断来通知：

硬件：通过系统总线发送信号到CPU，以触发中断

软件：通过系统调用，来触发软中断

系统会预定义部分中断，而这些中断可以通过查表来直接找到对应的中断处理程序，然后执行中断处理程序，而不需要通过其他中介程序了。通常这个指针表位于低地址内存（<100的位置），而这些位置包含各种设备的中断处理程序的地址——称为**中断向量**

Windows和Linux都是，对于任一给定的中断请求，可通过唯一的设备号来索引，进而找到提供设备的中断处理程序的地址

中断时，需要保存当前的寄存器的信息和返回地址（保存在堆栈中，以前是保存在某个固定的位置）

数据结构：位图（bitmap）：当需要表示大量资源的可用性时，一般采用位图。eg：磁盘，磁盘可以被分为数千个单元，每个单元就是磁盘块，对于每个磁盘块的可用性，可以用位图表示。