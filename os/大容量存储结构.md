# 大容量存储结构

# ——磁盘

现代计算机的大量辅助存储是硬盘驱动器（HDD）和非易失性存储器（NVM）设备

SSD：固态磁盘，和下面的传统磁盘相比，更可靠，且没有移动部件。并且不需要寻道和延迟，所以速度更快；耗能更少。但是，更贵、容量大寿命也短。

## 1. 磁盘结构

- 盘片：就是圆盘，类似于唱片。两面均涂了磁性材料，对盘片进行磁性记录可以保存信息
- 磁道：盘片上同心圆，是人为划分的，一个盘片上可以有多个磁道
- 扇区：就是磁道上的部分扇形区域，一个磁道可以有多个扇区。**是最小的物理存储单位**，主要有512B/4K两种大小
- 磁头：就是直接和盘片接触的，由磁臂进行控制到指定位置。
- 磁臂：所有磁头都作为一个整体一起动（不能磁头各动各的）
- 柱面：同一磁臂位置的的磁道构成了柱面（就是一个圆柱形），柱面可以由多个盘片上的磁道构成

——一个磁盘驱动器可能有数千个柱面（有数千个磁道），一个磁道有数百个扇区

<img src="pic\image-20210403092417099.png" alt="image-20210403092417099" style="zoom:67%;" />

衡量单位：

1. 每分钟转数RPM：一般为5400、7200、10000...
2. 传输速率：驱动器和计算机之间的数据传输速度
3. 定位时间/随机访问时间：
   1. 寻道时间：移动磁臂要指定磁道的时间
   2. 旋转延迟：旋转磁臂要指定扇区的位置

故障：

磁头并不能直接接触磁盘表面，否则会损坏磁盘表面——磁头碰撞（不是磁头之间碰撞），这个故障不可修复，必须替换整个磁盘

磁盘可以移动。可移动磁盘一般只有一个盘片，eg：CD、DVD等。

磁盘通过IO总线连接到计算机。

**磁盘有专门的磁盘控制器**

如果要在磁盘中找数据，那么需要主机控制器向磁盘控制器发送命令 -> 磁盘控制器收到命令后操作磁盘驱动硬件，执行命令 -> 磁盘驱动器将数据加载到缓存（磁盘内部常有内置缓存，所以是从盘片到缓存之间进行数据传送）-> 从缓存到主机之间的数据传输。

磁盘如何查找：

磁盘可以看成**逻辑块的一维数组。逻辑块就是磁盘的最小传输单位**，一般为512B。——其实就是一个扇区。

扇区0就是最外面的柱面的第一个磁道的第一个扇区。映射按磁道内的扇区顺序、柱面内的磁道顺序、从外到内的柱面顺序来进行映射的。

所以按照该映射，理论上，可以将逻辑块号转换为磁盘内的柱面号 + 柱面内的轨道号 + 磁道内的扇区号。

## 2. 磁盘调度⭐

读写一个磁盘块的时间的影响因素有：

- 旋转延迟：转到指定扇区，主轴转动盘面，使得磁头移动到适当的扇区上
- 寻道时间：找到指定的磁道，制动手臂移动，使得磁头移动到适当的磁道上
- 实际的数据传输时间

其中，**寻道时间最长**，因此磁盘调度的主要目标是使磁盘的**平均寻道时间最短**。

就是给定一个请求的柱面顺序，找到合适的寻道顺序：

eg：98, 183, 37, 122, 14, 124, 65, 67。从53位置开始进行寻道

### 2.1 先来先服务FCFS

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

<img src="pic\image-20210403100753788.png" alt="image-20210403100753788" style="zoom:67%;" />

### 2.2 最短寻道时间优先SSTF

**优先调度与当前磁头所在磁道距离最近的磁道。**

虽然平均寻道时间比较低，但是**不够公平**。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

且并非最优的。

<img src="pic\image-20210403100908314.png" alt="image-20210403100908314" style="zoom:67%;" />

### 2.3 电梯算法SCAN

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

SCAN算法：**总是按一个方向来进行磁盘调度，直到到达磁盘另一端，然后改变方向。**（所以触底才反弹）如果请求正好在磁头前方加入队列，那么马上能得到执行；如果请求在磁头后方加入队列，那么需要等待反转方向之后才能移动到这边。

因为考虑了移动方向，**因此所有的磁盘请求都会被满足**，解决了 SSTF 的饥饿问题。

### 2.4 C-SCAN调度

它是SCAN的变种，C-SCAN是触底之后又回到开头重新扫描，所以一直是同一方向。

### 2.5 Look调度 和 C-Look调度

就是发现该方向上没有请求了，就改变方向，而SCAN算法是一直要触底才会反弹。

<img src="pic\image-20210403102315923.png" alt="image-20210403102315923" style="zoom: 50%;" />

### 2.6 如何选择磁盘调度算法

主要与应用场景相关

eg：如果是读取连续分配的文件，那么文件内容都集中在临近位置，采用SSTF较优；而如果文件分散在多个块上，会导致更多的磁盘移动，所以用SCAN算法更优。

并且存储的布局也很有关系：读取文件需要先查找目录索引才能找到该文件。而目录结构也是按照文件形式存储的。如果目录文件在第一个柱面，而文件内容在最后一个柱面，则寻道时间就是最差的。

## 3. 磁盘管理

### 3.1 磁盘格式化

新的磁盘就是一个空的结构。

刚开始初始化，需要将其分扇区，那么才能进行读写——**低级格式化/物理格式化**。

每个扇区的数据结构：头部、数据部分、尾部

头尾包含了关于该扇区的控制信息，eg：扇区号、纠错代码ECC

当写入数据时：写完后会重新计算ECC；

当读取数据时：会先计算ECC，和原来的ECC比较，如果值不一样，那么该扇区的数据已经损坏，扇区可能也坏了

ECC可以进行一定的纠错，如果只有少许数据损坏，那么可以识别损坏的位置然后改正。

并且，对于很多磁盘，在低级格式化的时候，可以指定数据区域的大小。如果采用较大扇区，那么每个磁道的扇区变少了，但是相对的头尾信息变少，数据部分变多。

如果需要让磁盘存储数据，os需要将自己的数据结构存储在磁盘上。

- **磁盘分为由柱面组成的多个分区**，每个分区都可以抽象看成一个单独的磁盘

  eg：一个分区存储代码，一个分区存储数据。

- **逻辑格式化/创建文件系统**。操作系统将初始的文件系统数据结构存储到磁盘上。数据结构包括空闲和已分配的空间和一个初始为空的目录。

### 3.2 引导块

开始运行计算机时，需要有一个引导程序——**bootstrap**。

boostrap：会初始化所有的CPU寄存器和设备控制器、内存。然后从磁盘中找到操作系统内核，然后加载到内存，开始运行操作系统。

**boostrap存储在ROM**。

更为常见是：ROM只会存储一个更小的bootstrap，通过它可以找到完成的引导程序。而完整的引导程序存储在磁盘的固定位置——具有**启动分区的磁盘被称为启动磁盘 or 系统磁盘**。

eg：Windows为例：

Windows可以将磁盘分为多个分区，有一个分区为引导分区：包含操作系统和设备驱动程序。

Windows将该引导代码存放在磁盘的第一个扇区——**主引导记录MBR**。MBR中还包含一个表：列出磁盘分区，一个标志：指示从哪个分区引导系统。

引导首先会运行在ROM内存中的代码，该代码会指示从主引导MBR中去读引导代码。

### 3.3 坏块

如果出现的故障是磁盘，那么需要更换整个磁盘。如果坏的是一个或者多个扇区，那么在格式化扫描磁盘的时候发现坏块就标记为不可用，那么文件系统将不再使用它。如果在正常操作时突然变坏，那么人工运行特殊程序找到并且标记。

**坏块中的数据通常都会丢失。**所以，需要尽快处理坏块。

更为复杂的磁盘在恢复坏块时更为智能。就是提供一些备用扇区（对操作系统是不可见的，所以在编号上都是跳过它们的），eg：在每个柱面保留少量备用块，然后如果出现坏块就用该备用块进行替换。

有些控制器可以用扇区滑动来替代坏块，eg：17变坏了，而第一个备用扇区在202，那么就将18~201的内容均向后移动一位，那么扇区17还是能够得到映射的。

## 4. 交换空间管理

系统将交换和虚拟内存技术和交换页面结合起来，虚拟内存用磁盘空间作为内存的扩展。

### 4.1 交换空间的使用

不同的os使用交换空间的方式也不同。

交换空间的高估要比低估更为安全。

eg:Linux允许使用多个交换空间，包括文件的交换空间、专用的交换空间。不同的交换空间存放在不同的磁盘上，那么分页和交换的IO系统的负荷可以分散在不同的IO带宽上。

交换空间可以是在：文件系统之上；也可以是单独的一个磁盘分区。

- 交换空间是文件系统内的一个大文件，那么按照普通的文件类型进行创建和分配空间——但是效率低，因为需要查找目录结构等
- 在原始分区上创建交换空间，不创建文件系统和目录，直接操作磁盘空间。——效率高。

### 4.2 举例

Linux：将交换空间仅作为内存备份，用来存储**匿名内存页面**。且没有文件系统。

Linux允许建立多个交换区。交换区可以是普通文件系统的交换文件，或原始交换分区。

每个交换区的结构：包含一系列的4KB的页槽，用来存储交换页面。

每个交换区维护一个交换映射，就是一个标志页信息的数组。如果值为0——页槽可用；>0——该交换页面的映射数量，1表示一个进程关联；3表示3个进程关联。

<img src="pic\image-20210404095943400.png" alt="image-20210404095943400" style="zoom:80%;" />

## 5. 磁盘冗余阵列RAID

磁盘冗余阵列主要是用来提高数据存储的可靠性。如果单个磁盘出现故障，也不会导致丢失。

RAID的结构：

- 可以将磁盘直接连接到总线上。OS会控制多个磁盘实现RAID的功能；
- 可以使用存储阵列/RAID阵列，这是一个独立的单元，有自己的控制器、cache、磁盘，那么OS只需要将其当成一个普通的磁盘来操作即可，它内部会实现备份

### 5.1 RAID的具体实现

如何实现数据的可靠性：引入冗余，存储额外的信息，从而在发生故障的时候通过额外信息来实现数据的恢复。

最简单的方法（代价也最大）：重复每个磁盘——**镜像**，每个逻辑磁盘都有两个物理磁盘，每次写入都是写两份，这个就是镜像卷。如果某个磁盘出现故障，可以从另外一个里面恢复。对于可能存在的电源故障，即在完成写入之前发生断电情况，那么镜像卷之间可能存在状态不一致的情况。所以一般选择先写入一个，后面复制到另一个。还有为RAID提供固态**非易失性RAM**，那么在出现电源故障的时候数据还是能够保存下来的。

提高可靠性的另一个方法：奇偶位

有多个磁盘，也可以尝试并行访问，提高性能。

eg：对于镜像磁盘，可以并行的读，所以总时间会减少一半，每个磁盘的读取速率没有变化，但是总的速率加倍了。

如果采用多个磁盘，那么可以将数据存储在不同的磁盘上，然后读取的时候并发读取，速率也会增加。

eg：数据分条，就是将每个字节都分散在多个磁盘上。——**位级分条**。	

​		例如，有8个磁盘，那么可以将1个字节的8位都分散在8个磁盘上，第i个磁盘写入第i位——有8倍的访问速率。

还可以**块级分条**，将文件的块分散在每个磁盘上，如果有n个磁盘，那么第i块，可以存储在(i mod n) + 1上

——块级分条最常见

所以数据读取的并行化：

- 通过负载平衡，增加了多个小访问的吞吐量——增加一个时刻的访问的个数
- 降低大访问的响应时间——减少总时间

### 5.2 RAID级别

主要是：镜像代价太高，1：1的冗余比；并发操作，能够加快读取性能，但是未提高可靠性。

所以：RAID提供了多种级别，在并发性能和可靠性上做了一个均衡。

1. RAID级别0

   块分条，但是不含冗余码

   <img src="pic\image-20210404150436782.png" alt="image-20210404150436782" style="zoom:80%;" />

2. RAID级别1

   磁盘镜像

   <img src="pic\image-20210404150505670.png" alt="image-20210404150505670" style="zoom:80%;" />

   （c是副本；p是纠错位）

3. RAID级别2

   **基于奇偶位的错误检测：对每个字节中1的个数进行统计，是出现了偶数个1还是出现了奇数个1**，并且还带了差错纠正方案，所以需要3个磁盘来存储信息

   所以如果字节中一个位发生损坏，那么计算得到的值和校验位不匹配——所以，它能够检测单个位的差错

   位级分条，那么可以将一个字节分别存在不同的磁盘上，而校验码存储在其他磁盘上

4. RAID级别3

   位交错奇偶校验

   即认为，如果扇区损坏，磁盘控制器会检测出来，所以只需要计算奇偶位就可以了。

   所以，扇区损坏可以用磁盘控制器获得，然后通过剩余位的奇偶位计算，可以推出损坏的位原来是1/0。所以，只需要一个磁盘即可。

   比2常用。

   优势：多个磁盘只需要一个磁盘进行校验码的存储，节省空间；且按位分条，并发操作利用完全，速率更快

   劣势：每次写入和读取都需要进行奇偶运算，所以写入更慢了，所以很多磁盘都自带了专门的计算奇偶校验位的硬件。

5. RAID级别4

   分块的奇偶校验

   <img src="pic\image-20210404151236651.png" alt="image-20210404151236651" style="zoom:80%;" />

   原理同RAID3.

   但是粒度变大，所以如果读取块，可以只占用一个磁盘的IO，而其他磁盘可以处理其他请求。那么每个块的读取速率反而变慢，因为还需要进行校验，但是并发读取的话，效率更高。

   所以，大块读取速率很高，写入也很高，因为可以并行写入数据和进行奇偶校验。

   小块，需要进行4次磁盘访问：第一次读 + 读取奇偶校验码验证，cpu对数据进行修改后然后写回，写入数据，写入奇偶校验码。

6. RAID级别5

   块交错分布的奇偶校验结构。

   它会将数据和数据校验码分散在N个磁盘上。而不是校验码统一在一个磁盘上。

   eg：5个磁盘，第n块的奇偶校验码保存在磁盘(n mod 5) + 1上，而其他4个磁盘的第(n mod 4) + 1块用来存储真正的数据

   <img src="pic\image-20210404162418397.png" alt="image-20210404162418397" style="zoom:80%;" />

   优势：可以减少一个奇偶校验盘的过度使用，对于上面2、3、4方案，奇偶校验盘每次读取和写入都需要进行访问，所以损耗比其他的严重。

   RAID5是最常见的奇偶校验的RAID方案。

7. RAID级别6

   P+Q冗余方案

   在5的基础上，保存了冗余码，防止多个磁盘同时出现故障。

8. RAID0+1、RAID1+0

   位分条 + 镜像，一组磁盘分条，另一组对其进行镜像。所以磁盘数也加倍了。但是即增加了可靠性，也增加了并行性。

   ——如果一个磁盘出现故障，那么其他条也无法使用了（读取的数据的1块存在问题），即使其他条的磁盘并没有问题

   RAID1+0，对磁盘先镜像，再分条

   ——如果一个磁盘出现故障，而其他条还是可以使用的。

大多数磁盘阵列实现的是热备份：就是有些磁盘是未进行分配的，只有在出现故障的时候，自动替换出现故障的磁盘然后重建数据。

快照：在最后一次更新文件系统的视图

复制：不同站点之间的自动复制写入。同步的复制：在写入完成之前，必须在本地和远程的结点中写入每块；对于异步复制，写入是定期的。异步复制存在的问题，由于是定期复制，所以在这个期间出现问题，那么数据将会丢失。

## 6. 稳定存储

磁盘需要保证在更新数据的过程中，即使出现故障也不会所有副本都出现损坏，那么能够及时恢复；还保证，如果恢复的时候出现另一故障，也让所有副本能够保证正确的状态。

磁盘写入时的结果：

- 正确写入：数据已经正确存放到磁盘
- 部分故障：在数据传输的过程中出现故障，那么有些扇区正确写入了，而正在写入的扇区发生故障
- 完全故障：在写入之前就已经故障了，那么磁盘保持之前的数据状态

想要正确恢复，一个逻辑块要有两个物理块：

- 将信息写入第一个物理块
- 当第一个写入成功之后，才会将同样的数据写入第二个物理块
- 只有第二个写入也成功之后，才能返回成功

——只有两个盘相等，且不存在可检测的错误，才不需要进行操作；如果一个磁盘检测到可检测的错误，那么需要用另一块的数据复制过去；如果没有可检测到的错误的，那么用第二块的值替换第一块，所以能够保证写入完全正确 or 没有变化。