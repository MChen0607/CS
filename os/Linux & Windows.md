# Linux & Windows

# 1. Liunx

多用户的抢占式的多任务系统。

Linux系统组件：

- 内核
- 系统库：内核程序可以通过调用这些API来实现内核的交互，在`libc`中。
- 系统工具：执行专门的就、单独的管理任务。

内核代码在特权模式下才能被执行，并且能访问计算机的所有资源。——**内核模式**

内核代码中没有用户代码

## 1.1 进程管理

`fork()/exec()`：fork是创建一个新的进程；exec是新进程运行新的程序进行了新的系统调用。

进程的特征：

- PID

- 凭证：每个进程必须具有关联的用户ID和一个或多个组ID，这些ID决定了该进程访问系统资源和文件的权限

- 个性personality：主要是兼容特色的UINX

- 命名空间：是文件系统层次结构的特定视图

  大多数进程都是共享同一个通用命名空间，但是进程和子进程也可以有不同的命名空间

进程环境：

从父进程那边继承过来。

- 参数向量：列出了用于调用正在运行的程序的命令行参数。 通常以程序本身的名称开头
- 环境向量：将命名的环境变量与任意文本值相关联。

刚创建时，参数向量和环境向量不会被修改，和父进程完全一致；只有新程序被调用时，才会设置全新的环境

进程上下文：

- **调度上下文**：用来挂起和重启进程前的操作，包括所有寄存器（浮点寄存器是有需要时候才会进行保存，没有用浮点运算的进程不会用到），还包括优先级、等待的信号等
- 记账：进程消耗的资源、从启动到现在占用的CPU等资源
- 文件表：打开文件表
- 文件系统上下文：请求打开新文件的文件系统上下文：进程的根目录、当前的工作目录、命名空间等
- 信号处理程序表：响应特定信号的行为。包括：忽略、终止进程等
- 虚拟内存上下文：进程私有地址空间的全部内容

## 1.2 调度

概述：支持抢占式的多任务

### 1.2.1 完全公平调度CFS

消除了传统的静态时间片的概念。

数据结构：0~99的实时范围和-20~19的友好值范围。实时范围按照实时调度进行；友好值越小优先级越高，增加友好值，是对其他进程友好的表现。

概念：**目标延迟：每个可执行任务应该运行至少一次的时间间隔**，eg：目标延迟为10ms，有100个进程且同优先级，那么每个进程能够运行0.1ms；

​			最小粒度：每个进程分配的最小时间长度（一个最小下限），防止因为进程数量增多，而进程分得的时间片过少而导致频繁的上下文切换。

调度器根据每个进程的友好值分配不同长度的时间片

### 1.2.2 实时调度

Linux的实时调度是软实时的，并不能保证一定在限定时间内得到执行。

实现了POSIX要求的两种调度算法：FCFS和时间片轮转。

为每个进程设置优先级，总是运行最高优先级的进程，如果优先级一样按照FCFS运行。

### 1.2.3 内核同步

对于单处理器：禁用内核抢占来实现同步；对于多处理器：持有自旋锁来实现同步。

Linux为了防止中断处理程序执行时间过长，所以选择将中断处理程序分为**上半部分和下半部分**，上半部分是标准的中断服务程序，禁止递归执行，但是可以被其他高优先级的中断打断；下半部分，所有中断都会被启用，就是中断处理程序已经退出了，下半部分的处理可以被上半部分给中断，但是下半部分之间不能被中断。

## 1.3 内存管理

### 1.3.1 物理内存管理

Linux将物理内存分为4个不同区域：

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210406172445696.png" alt="image-20210406172445696" style="zoom:80%;" />

每个区域都有一个空闲页面列表，每个区域都有一个页面分配器。

分配器用buddy算法

Linux分为静态分配和动态分配：

- 静态分配：在系统启动时已经预留了连续内存区域
- 动态分配：在程序执行时才能进行页面分配，使用的是页面分配器

还有一个slab分配算法，主要是为内核的数据结构分配内存，在cache中存放对象。

Linux采用：页面缓存和虚拟内存系统。

页面缓存：是文件缓存的实现；与块设备进行IO操作的主要机制

虚拟内存系统：管理每个进程的虚拟地址空间的内容。

### 1.3.2 虚拟内存

Linux虚拟内存系统主要就是维护每个进程可访问的地址空间。创建虚拟内存页面，从磁盘中加载需要的页面到内存，并且将用不到的页面交换回磁盘。

交换和分页：

- 页面换出策略：每个页面都有一个年龄，每次时钟都会更新寿命——年龄实际上是页面的最近活跃度，如果活跃度高的，那么年龄就大，就不容易被换出——按照LFU的策略被换出
- 分页机制：分配使用next-fit算法，空闲块的表示用位图

### 1.3.3 执行和加载用户程序

用exec来触发子进程调用新的程序。注意初始上下文会完全覆盖当前上下文

在执行exec命令之前，需要验证：验证该进程是否有权限执行该文件。如果有，内核才能加载程序

Linux没有一个单独的程序加载新程序，而是**维护了一个可能加载程序函数表，在执行exec时，让表内的每个函数都有机会试图加载给文件**，格式时ELF/.out（旧的）

初始时，二进制加载器不会讲ELF文件加载到内存，而是映射到虚拟内存区域，当需要访问指定页面的时候，发生缺页错误后才会将对应的页面加载到物理内存。

**二进制加载器负责初始内存映射**。ELF包括一个头部和多个页面对齐的部分，ELF加载器通过读取标头并将文件的各个部分映射到虚拟内存的不同区域。

加载器复杂初始内存映射的区域包括：栈、程序文本、数据区域。

程序运行，所有必要的内容都要加载到进程的虚拟地址空间。因为程序需要调用系统库，所以这些库也需要进行加载：

- 静态加载：库函数直接嵌到程序的可执行二进制文件中，那么程序加载后，就能开始运行——库函数和普通函数混为一体了

  每个程序都要有库函数的副本

- 动态加载：包含一个小的静态链接函数，该函数在进程启动的时候被调用，将库映射到内存，并且映射库到内存，然后这些库被编译成位置无关代码，在内存的何种位置都能够找到并运行

  只需要一次加载到内存，就都可以使用了

## 1.4 文件系统

通过VFS可以隐藏任何单个文件类型的实现细节，从而能够处理所有类型的文件。

### 1.4.1 虚拟文件系统

面向对象原则，有4个主要对象：

- inode对象：表示单个文件
- file对象：打开的文件
- 超级块对象：整个文件系统
- dentry对象：单个目录条目

每个对象都定义了一组操作。

inode对象和文件对象：都是操作文件的，文件对象是针对单个进程的；inode对象是针对唯一的一个文件的。即即使文件对象不存在了，而inode对象还是存在的，可能仍由VFS缓存从而提高访问速度。目录文件的处理和其他普通文件有不同，不会要求用户去打开文件才能继续操作

超级块对象：主要是提供inode访问

### 1.4.2 ext3

Linux采用标准磁盘文件系统——ext3

在分配文件的时候，先给文件选择块组（块组就是柱面组，同属物理磁盘的单个柱面的组），数据块就尽量分配到与文件inode相同的块组。

在一个块组内，尽量选择连续的物理地址，以减少碎片。所以ext3会维护空闲空间的位图。

分配的策略：

- 如果能在开始搜索的附近找到足够多的空间（可以是离散的），那么就选择它们，它们之间需要有链接信息。——所以它们还是汇聚在一起的，所以磁盘寻道时间短
- 如果不能立即搜到足够的空间，那么查找整个位图的空闲字节，然后作为一个整体进行分配

<img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20210406212653586.png" alt="image-20210406212653586" style="zoom:67%;" />

### 1.4.3 日志

对文件系统的修改会按照时间记录下来。

执行某个特定任务的一组操作，被称为事务。事务一旦写到日志了，就会被认为已提交。

## 1.5 IO

所有设备驱动程序尽可能地显示为普通文件。用户打开设备访问通道，就等同于打开文件。

Linux将设备分为3类：块设备、字符设备、网络设备

- 块设备：完全独立地、固定大小数据块的所有设备的随机访问，eg：硬盘等——随机访问
- 字符设备：eg：键盘、鼠标等——串行访问
- 网络设备

### 1.5.1 块设备

传统的使用的是SCAN算法，Linux2.6引入了**完全公平排队CFQ**

CFQ：维护一组列表，一个进程一个列表，列表内部使用C-SCAN算法；当C-SCAN算法对一个进程无效的时候，采用轮转方式处理列表，从每个列表中提取出4个请求，调度器每次执行一个进程的4次请求，执行完成之后移到下一个进程去执行4个请求....——那么进程都能得到相同比例的磁盘带宽。——公平

## 1.6 进程间通信

用管道通信。

## 2. Windows

